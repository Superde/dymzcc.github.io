<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>虚函数</title>
      <link href="/2021/05/21/xu-han-shu/"/>
      <url>/2021/05/21/xu-han-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="总结写开头"><a href="#总结写开头" class="headerlink" title="总结写开头"></a>总结写开头</h2><p>编译器决定运行哪个代码块的代码，称为联编。在编译阶段完成联编称为静态联编，在程序运行阶段完成联编称为动态联编。<br>C++通过虚函数实现动态联编，类的成员函数可以分为两类，一类是希望完全继承不做修改，另一类是希望子类能做选择性修改。第二类就是虚函数，通过在基类的函数前加上virtual关键字，声明其为虚函数。然后可以在子类中重写该函数，运行时将会根据基类指针所指对象的实际类型，来选择性地调用相应的函数。如果对象类型是子类，就调用子类的函数，如果对象类型是基类，就调用基类的函数。<br>虚函数是通过虚函数表来实现的，虚函数表是一个一维数组，存放着虚函数的入口地址。每个类都有一张虚函数表，每个类的对象都有一个虚函数指针，指向各自类的虚函数表。<br>在构造时，根据对象的类型去初始化虚函数指针，使他指向正确的虚表，从而在调用虚函数时，能调用正确的虚函数<br>这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数的重写情况动态地进行调用，从而实现动态联编</p><p>由于每个类都有一张虚函数表，该类的所有实例都共享一张虚函数表，因此虚函数表存储在全局存储区<br>实际上虚函数指针是在构造函数执行时初始化的，而虚函数表是存放在可执行文件中的<br>在gcc编译器的实现中虚函数表vtable存放在可执行文件的只读数据段.rodata中</p><h2 id="一、联编"><a href="#一、联编" class="headerlink" title="一、联编"></a>一、联编</h2><p>程序调用函数时，具体应使用哪个代码块是由编译器决定的，以函数重载为例，C++编译器根据传递给函数的参数和函数名决定具体使用哪一个函数，称为联编<br>编译器在编译过程中完成这种联编，称为静态联编；在程序运行过程中完成联编，称为动态联编<br>C++通过虚函数来实现动态联编</p><h2 id="二、虚函数定义和使用"><a href="#二、虚函数定义和使用" class="headerlink" title="二、虚函数定义和使用"></a>二、虚函数定义和使用</h2><h4 id="虚函数定义"><a href="#虚函数定义" class="headerlink" title="虚函数定义"></a>虚函数定义</h4><p>C++中，基类必须将它的两种成员函数分开：（1）基类希望派生类直接继承而不做改变的函数（2）基类希望派生类进行覆盖的函数。第二类函数通常就定义为虚函数。虚函数允许派生类重新定义与基类同名的成员函数，并且可以通过基类指针或者引用来访问基类和派生类中的同名函数<br>虚函数的定义很简单，只要在成员函数原型前加关键字virtual，如果一个基类的成员函数定义为虚函数，那它在派生类中也为虚函数，即使派生类中省略了virtual也仍是虚函数。<br>派生类中可以对虚函数重新定义，重新定义有以下要求：</p><ol><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回类型</li></ol><p>不能定义为虚函数的函数：（1）普通函数（非成员函数）（2）静态成员函数（3）构造函数（4）友元函数</p><h4 id="虚函数的使用"><a href="#虚函数的使用" class="headerlink" title="虚函数的使用"></a>虚函数的使用</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">person</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"1"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"2"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">student</span> <span class="token operator">:</span> <span class="token keyword">public</span> person<span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"3"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//隐藏：派生类的函数屏蔽了与其同名的基类函数</span>    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"4"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//多态、覆盖</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（1）通过对象名访问</strong><br>通过对象名进行访问时，编译器采用的是静态联编，虚函数和普通函数一样，调用哪个类的函数决定于对象名的类型：对象类型是基类时，就调用基类的函数；对象类型时子类时，就调用子类的函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp">person a<span class="token punctuation">;</span>student b<span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1</span>a<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2</span>b<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3</span>b<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2）通过指针访问</strong><br>使用指针访问虚函数：编译器根据指针所指对象类型决定调用哪个函数，而不是根据指针的类型<br>使用指针访问非虚函数：编译器根据指针的类型决定调用哪个函数，而不是根据指针所指对象的类型</p><pre class="line-numbers language-cpp"><code class="language-cpp">person a<span class="token punctuation">;</span>student b<span class="token punctuation">;</span>person <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>p<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出1</span>p<span class="token operator">-</span><span class="token operator">></span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出2</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>  p<span class="token operator">-</span><span class="token operator">></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//取决于指针类型，输出1</span>p<span class="token operator">-</span><span class="token operator">></span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//取决于对象类型，输出4，体现了多态</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（3）使用引用访问虚函数</strong><br>与使用指针访问虚函数类似，不同的是，引用一经声明后，引用变量本身无论如何改变，其调用的函数就不会改变，始终指向其开始定义的函数。</p><p><strong>虚函数特性</strong></p><ol><li>若在基类中，只是声明虚函数原型(需要加上virtual)，而在类外定义虚函数时，则不必再加上virtual</li><li>在派生类中重新定义时，其函数类型、函数名、参数个数、参数类型的顺序，都必须与基类中的原型完全相同</li><li>C++规定，当一个成员函数被定义为虚函数后，其派生类中符合重新定义虚函数要求的同名函数都自动称为虚函数。因此，在派生类中重新定义该虚函数时，关键字virtual可写可不写。但是为了程序更加清晰，最好在每一层派生类中定义函数时都加上关键字virtual</li><li>如果在派生类中没有对基类的虚函数重新定义，则公有派生类继承其直接基类的虚函数</li><li>一个虚函数无论被公有继承多少次。它仍然保持其虚函数的特性</li></ol><h2 id="三、虚函数与构造函数、析构函数"><a href="#三、虚函数与构造函数、析构函数" class="headerlink" title="三、虚函数与构造函数、析构函数"></a>三、虚函数与构造函数、析构函数</h2><p><strong>（1）构造函数不能为虚函数</strong></p><ul><li>创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等</li><li>虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了</li></ul><p><strong>（2）析构函数最好为虚函数</strong><br>在C++开发中，基类的析构函数一般都是虚函数。如果父类的析构函数不加virtual关键字，子类继承父类，父类的指针指向子类时，delete掉父类的指针，只调用父类的析构函数，不会调用子类的析构函数；如果父类的析构函数加virtual关键字，子类继承父类，父类的指针指向子类时，delete掉父类的指针，先调用子类的析构函数，再调用父类的析构函数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ClxBase</span><span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">ClxBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">ClxBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"delete ClxBase"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Do something in class ClxBase!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">ClxDerived</span> <span class="token operator">:</span> <span class="token keyword">public</span> ClxBase<span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">ClxDerived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token operator">~</span><span class="token function">ClxDerived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Output from the destructor of class ClxDerived!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Do something in class ClxDerived!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token keyword">const</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     ClxBase <span class="token operator">*</span>pTest <span class="token operator">=</span> <span class="token keyword">new</span> ClxDerived<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//父类指针指向子类对象</span>     pTest<span class="token operator">-</span><span class="token operator">></span><span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">delete</span> pTest<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//如果父类析构函数不为虚函数，则此时只调用父类的构造函数，不会调用子类的构造函数，这时就会内存溢出</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  这个之前也提到，如果使用指针访问非虚函数，编译器根据指针的类型决定调用哪个函数，而不是根据指针所指对象的类型，该指针是父类指针，delete该指针只会调用父类的析构函数。<br>  那为什么用虚析构函数后，子类的析构函数也会调用？由于父类的析构函数为虚函数，所以子类会在所有属性前形成一张虚函数表，虚函数表里存储的就是父类的虚函数和自己定义覆盖了父类的虚函数。当delete父类的指针时，由于子类的析构函数与父类的析构函数构成多态，此时调用的函数由指针所指的对象决定，所以先执行子类的析构函数，再执行父类的析构函数。<br><strong>（3）构造函数和析构函数中的虚函数</strong><br>构造派生类对象时，先调用父类的构造函数，再调用派生类的构造函数。在执行父类的构造函数的这个过程中，对象的派生类部分是未初始化的，此时该对象是被认为是基类类型对象，当执行完派生类的构造函数后，才成为派生类对象。撤销派生类对象时也是一样。<br>如果在构造函数和析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本。<br>这种在构造函数和析构函数中调用虚函数的行为是非常不提倡的。</p><h2 id="四、虚函数原理"><a href="#四、虚函数原理" class="headerlink" title="四、虚函数原理"></a>四、虚函数原理</h2><p>虚函数是通过一张<strong>虚函数表</strong>实现的，虚函数表解决了继承、覆盖、添加虚函数的问题。如果一个类中有虚函数，那么该类就有一个虚函数表，所有该类的实例对象都会有一个虚函数表指针指向该类的虚函数表。<br>为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针指向虚表，当类的对象在创建时，就拥有了这个指针，且指针自动指向类的虚表。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2897574/1617193987924-54f76800-47b6-40be-86a9-a645d6ce631b.png#align=left&display=inline&height=388&margin=%5Bobject%20Object%5D&originHeight=776&originWidth=1384&size=0&status=done&style=none&width=692" alt><br>只要基类有虚函数，那么子类就有虚函数表，而且基类的虚函数表和子类的虚函数表不是同一个表。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">vfunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">vfunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> m_data1<span class="token punctuation">,</span> m_data2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token keyword">public</span> A <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">vfunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> m_data3<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span> <span class="token keyword">public</span> B <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">vfunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> m_data1<span class="token punctuation">,</span> m_data4<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2897574/1618538560576-d194f7eb-65b6-4cae-9a5d-6fe1eb78c335.png#align=left&display=inline&height=636&margin=%5Bobject%20Object%5D&originHeight=636&originWidth=637&size=0&status=done&style=none&width=637" alt></p><p>图中类A是基类，类B继承类A，类C继承类B。三个类都有虚函数，因此三个类都有虚函数表，且三个类的对象都有一个虚表指针<code>_vptr</code>指向各自的虚表。</p><blockquote><p>分析：<br>A中有两个虚函数<code>A::vfunc1()</code>和<code>A::vfunc2()</code>，A虚表中有两个指针指向这两个函数<br>B继承与B，故B可以调用A的函数，但B重写了<code>vfunc1()</code>，因此B虚表中有两个指针，分别指向<code>A::vfunc2()</code>和<code>B::vfunc1()</code><br>C继承于B，故C可以调用B的函数，但C重写了<code>vfunc2()</code>，因此C虚表中有两个指针，分别指向<code>B::vfunc1()</code>和<code>C::vfunc2()</code></p></blockquote><p>现在定义一个类B的对象<code>object_b</code>，声明一个类A的指针<code>pa</code>来指向这个<code>object_b</code>。虽然<code>pa</code>是基类的指针，只能指向基类的部分，但是虚表指针属于基类部分，因此<code>pa</code>可以访问到<code>object_b</code>的虚表指针</p><blockquote><p>现在调用<code>pa-&gt;vfunc1()</code>：</p><ol><li>编译器发现<code>pa</code>是个指针，且调用的函数是虚函数</li><li>然后通过<code>pa-&gt;_vptr</code>访问对象<code>object_b</code>的虚表</li><li>在虚表中查找所调用函数对应的条目</li><li>根据该条目的函数指针，调用函数</li></ol></blockquote><p><strong>一言以蔽之，在构造时，根据对象的类型去初始化虚指针**</strong><code>_vptr</code><strong><strong>，从而让</strong></strong><code>_vptr</code><strong>**指向正确的虚表，从而在调用虚函数时，能找到正确的函数</strong></p><h2 id="五、纯虚函数"><a href="#五、纯虚函数" class="headerlink" title="五、纯虚函数"></a>五、纯虚函数</h2><p>纯虚函数是一种特殊的虚函数，其格式如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> 类名<span class="token punctuation">{</span>  <span class="token keyword">virtual</span> 类型 函数名<span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>凡是有纯虚函数的类称为抽象类</strong>，这种类不能声明，不能实例化对象，只是作为基类为派生类服务。只有当<strong>派生类实现了基类的所有纯虚函数</strong>，派生类才可以实例化对象，否则派生类也是抽象类。<br>在基类中不能对虚函数给出有意义的实现时，可以将它声明为纯虚函数，将它的实现留给派生类去实现。就好像基类是动物，派生类可以有猴子、老虎、孔雀等等，猴子这些都可以有实体对象，但是基类动物本身生成对象就不合理。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内联函数</title>
      <link href="/2021/05/20/nei-lian-han-shu/"/>
      <url>/2021/05/20/nei-lian-han-shu/</url>
      
        <content type="html"><![CDATA[<p>在C/C++中，如果一些函数被频繁调用，不断地有函数入栈，会造成栈空间的大量消耗</p><blockquote><p><strong>栈空间</strong>：就是指放置程式的局部数据也就是函数内数据的内存空间，在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足所造成的程式出错的问题，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。</p></blockquote><blockquote><p><strong>调用函数的花销会有多大</strong>：当遇到普通函数的调用指令时，程序会保存当前函数的执行现场，将函数中的局部变量以及函数地址压入堆栈，然后再将即将调用的新函数加载到内存中，这要经历复制参数值、跳转到所调用函数的内存位置、执行函数代码、存储函数返回值等过程，当函数执行完后，再获取之前正在调用的函数的地址，回去继续执行那个函数，运行时间开销简直太多了。</p></blockquote><p>内联函数是C++的增强特性之一，用来降低程序的运行时间。当内联函数收到编译器的指示时，即可发生内联；<strong>编译器在函数调用出使用函数体本身语句来替代函数调用语句</strong>，这种替代行为发生在编译阶段而非程序运行阶段。因此通过使用内联函数，编译器不需要跳转到内存其他地址去执行函数调用，也不需要保留函数调用时的现场数据</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"奇"</span> <span class="token operator">:</span> <span class="token string">"偶"</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token function">test</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实在内部的工作就是在每个for循环内，所有调用<code>test()</code>函数的地方，都换成了<code>(a % 2 &gt;0) ? &quot;奇&quot; : &quot;偶&quot;</code>，这样就避免了频繁调用函数对栈内存重复开辟带来的消耗</p><p>值得注意的是，<strong>内联函数仅仅是对编译器的内联建议</strong>，编译器是否觉得采取你的建议取决于函数是否符合内联的有利条件。如何函数体非常大，那么编译器将忽略函数的内联声明，而将内联函数作为普通函数处理；同样地，一些没有<code>inline</code>声明的函数编译器也会将它内联展开</p><p><strong>总结：</strong></p><ol><li>内联函数是以代码复制为代价，省去了函数调用的开销，从而提高函数的执行效率</li><li>内联函数只适用于函数体内代码简单的函数使用，不能包含复杂的结构控制语句如while、switch，并且内联函数本身是不能直接递归的</li><li>内联函数只是对编译器的建议，编译器是否采用内联措施由编译器自己来决定</li><li>类中所有定义的函数都默认声明为<code>inline</code>函数，虚函数不允许内联</li><li>以下情况不宜使用内联函数：<ul><li>函数体内的代码较长，使用内联将导致内存消耗大</li><li>函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大</li></ul></li><li>将内联函数放在头文件里实现是合适的，省却为每个文件实现一次的麻烦。而所以声明跟定义要一致，其实是指，如果在每个文件里都实现一次该内联函数的话,那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为，即是说，如果不是每个文件里的定义都一样，那么编译器展开的是哪一个，那要看具体的编译器而定。所以最好将内联函数定义放在头文件中</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>友元函数和友元类</title>
      <link href="/2021/05/19/you-yuan-han-shu-he-you-yuan-lei/"/>
      <url>/2021/05/19/you-yuan-han-shu-he-you-yuan-lei/</url>
      
        <content type="html"><![CDATA[<p><strong>友元机制并没有破坏类的封装性</strong><br>乍看友元机制允许非成员函数访问私有变量，但是其实友元函数和成员函数只是类接口的两种实现而已。<strong>类声明仍控制了哪些函数可以访问私有数据和保护数据</strong>。</p><h2 id="一、友元函数"><a href="#一、友元函数" class="headerlink" title="一、友元函数"></a>一、友元函数</h2><p>在C++中，我们一般使用类来对数据进行隐藏和封装，将类的数据成员定义为私有成员，将成员函数定义为公有的，以给外部提供调用接口。但是有时候需要定义一些函数，这些函数不是类的成员，但是需要访问类的数据成员，这时就可以将这些函数定义为友元函数。声明格式：<code>friend 类型 函数名(形参表);</code><br><strong>友元函数是可以直接访问类的私有成员和保护成员的函数</strong>，分为两种：</p><ul><li><strong>类外定义的普通友元函数</strong><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>  <span class="token keyword">friend</span> <span class="token keyword">double</span> <span class="token function">distance</span><span class="token punctuation">(</span>Point <span class="token operator">&amp;</span>p1<span class="token punctuation">,</span> Point <span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>double distance(Point &amp;p1, Point &amp;p2) {<br>    double w = p1.x &gt; p2.x ? (p1.x - p2.x) : (p2.x - p1.x);<br>    double h = p1.y &gt; p2.y ? (p1.y - p2.y) : (p2.y - p1.y);<br>    return sqrt(w <em> w + h </em> h);<br>}</p><p>int main(){<br>    Point p1(0,0), p2(3,4);<br>    cout &lt;&lt; distance(p1, p2) &lt;&lt; endl;<br>    return 0;<br>}</p><pre><code>- **友元成员函数**```cpp//teacher类中的show()函数是student类中的友元函数,可以访问student类中的全部变量//需要首先声明student类class student;class teacher{public:    //teacher类访问student的私有变量age    void show(student &amp;stu);};class student{public:    student(int num = 0):age(num){ }    //声明teacher类的show函数是student类的友元函数    friend void teacher::show(student &amp;stu);private:    int age;};//只有定义了student类后才能定义友元函数,毕竟它被设为友元是为了访问类A的成员void teacher::show(student &amp;stu) {    cout &lt;&lt; stu.age &lt;&lt; endl;}int main(){    teacher t;    student s(17);    t.show(s);    return 0;}</code></pre><p><strong>友元函数的特性：</strong></p><ul><li>友元函数的声明可以放在类的私有部分，也可以放在类的公有部分，没有区别</li><li>一个函数可以是多个类的友元函数</li><li>友元函数的调用与一般函数的调用方式和原理一致</li><li>友元函数没有 <code>this</code> 指针</li></ul><p><strong>友元函数使用场景：</strong></p><ul><li>运算符重载的某些场合需要使用友元</li><li>两个类共享数据</li></ul><p><strong>友元函数的参数：</strong></p><ul><li>要访问非static成员时，需要对象作参数</li><li>要访问static成员或全局变量时，不需要对象作参数</li><li>如果做参数的对象是全局对象，则不需要对象作参数</li></ul><h2 id="二、友元类"><a href="#二、友元类" class="headerlink" title="二、友元类"></a>二、友元类</h2><p><strong>友元类的所有成员函数都是另一个类的友元函数</strong>，都可以访问另一个类中的私有成员和保护成员。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">student</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">student</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">age</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">teacher</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">teacher</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span>student <span class="token operator">&amp;</span>stu<span class="token punctuation">)</span><span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> stu<span class="token punctuation">.</span>age <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    teacher t<span class="token punctuation">;</span>    student <span class="token function">s</span><span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>友元类的特性：</p><ul><li>友元关系不能被继承</li><li>友元关系是单向的，不具有交换性<code>A -&gt; B, 不能推出 B -&gt; A</code></li><li>友元关系不具有传递性，<code>A -&gt; B, B -&gt; C, 不能推出 A -&gt; C</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类成员函数</title>
      <link href="/2021/05/19/lei-cheng-yuan-han-shu/"/>
      <url>/2021/05/19/lei-cheng-yuan-han-shu/</url>
      
        <content type="html"><![CDATA[<p>参数（右值）的符号必须是右值引用符号，即“&amp;&amp;”<br>参数（右值）不可以是常量，因为我们需要修改右值<br>参数（右值）的资源链接和标记必须修改。否则，右值的析构函数就会释放资源。转移到新对象的资源也就无效了</p><h2 id="一、成员函数"><a href="#一、成员函数" class="headerlink" title="一、成员函数"></a>一、成员函数</h2><p>在类内部的成员函数默认为内联函数，调用成员函数时，实际上是使用对象来调用的。每个成员函数(除了static成员函数)都有一个形参<code>this</code>。在调用成员函数时，形参<code>this</code>初始化为调用函数的对象的地址<br>当定义一个类时，通过定义四种特殊的成员函数来控制该类对象的创建、拷贝、移动、赋值、销毁，分别是普通构造函数、拷贝构造函数、移动构造函数、赋值构造函数、析构函数</p><h2 id="二、构造函数"><a href="#二、构造函数" class="headerlink" title="二、构造函数"></a>二、构造函数</h2><ul><li>构造函数是特殊的成员函数，其作用就是保证每个对象的数据成员具有合适的初始值</li><li>构造函数与类同名，而且没有返回类型</li><li>一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目、类型的形参</li></ul><p><strong>普通构造函数：</strong><br>如果一个类没有定义构造函数，那么编译器会自动为该类生成默认构造函数，默认构造函数不带任何参数。如果使用默认构造函数或自己定义了一个没有任何操作的构造函数，则类内成员：</p><ul><li>类成员：运行该类型的默认构造函数来初始化</li><li>内置或符合类型的成员：如果在全局作用域，则初始化为0；如果在局部作用域，则不被初始化<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">person</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>   <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">person</span><span class="token punctuation">(</span><span class="token keyword">int</span> Age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      age <span class="token operator">=</span> Age<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>person A(20);</p><pre><code>**拷贝构造函数：**如果用户没有定义，编译器也会自动生成一个拷贝构造函数，拷贝构造函数可用于：（1）根据一个同类型的对象初始化一个对象（2）拷贝一个对象，将它作为实参传给一个函数或从函数返回时拷贝一个对象```cppclass person{private:     int age;public:    person(const person &amp;p){        age = p.age;    }};person B(A);</code></pre><p><strong>赋值运算符：</strong><br>如果用户没有定义，编译器也会自动生成一个赋值运算符</p><blockquote><p>拷贝构造函数和赋值运算符都会自动生成<br>拷贝构造函数通常是用一个已有的对象去创建一个新对象<br>赋值运算符是将一个对象复制给另一个已存在的对象</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">person</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>     <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    person <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> person <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>            age <span class="token operator">=</span> p<span class="token punctuation">.</span>age<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>person C<span class="token punctuation">;</span>C <span class="token operator">=</span> B<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>转移构造函数：</strong><br>通过转移构造函数实现转移语义，可以将一个临时对象中的资源转移到其他对象里，减少新建、销毁对象带来的开销<br><strong>注意：</strong></p><ul><li>参数（右值）的符号必须是右值引用符号，即“&amp;&amp;”</li><li>参数（右值）不可以是常量，因为我们需要修改右值</li><li>参数（右值）的资源链接和标记必须修改。否则，右值的析构函数就会释放资源。转移到新对象的资源也就无效了<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">person</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>   <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">person</span><span class="token punctuation">(</span>person <span class="token operator">&amp;&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>      age <span class="token operator">=</span> p<span class="token punctuation">.</span>age<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//链接资源的标记必须修改，否则当临时对象析构时转移到新对象的资源无效</span>      p<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>person D(person(20));<br>person D(move(A));</p><pre><code>**转移运算符：**通过转移运算符实现转移语义，可以将一个临时对象中的资源转移到其他对象里，减少新建、销毁对象带来的开销```cppclass person{private:     int age;public:    //转移运算符    person &amp;operator=(person &amp;&amp;p){        if(this != &amp;p){            age = p.age;            //链接资源的标记必须修改，否则当临时对象析构时转移到新对象的资源无效            p.age = 0;        }        return *this;    }};person E;E = move(A);E = person(10);</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载、隐藏、覆盖</title>
      <link href="/2021/05/17/chong-zai-yin-cang-fu-gai/"/>
      <url>/2021/05/17/chong-zai-yin-cang-fu-gai/</url>
      
        <content type="html"><![CDATA[<p><strong>（1）重载</strong><br>重载的特性有：（1）相同的范围内，<strong>在同一个类中</strong>（2）函数名字相同（3）参数不同</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">int</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span>intb<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>           <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>（2）覆盖/重写</strong><br>覆盖的特性有：</p><ul><li>不同的作用范围，分别位于基类和派生类</li><li>函数的名字相同</li><li>参数个数、类型相同</li><li>函数返回值类型相同</li><li>基类函数必须virtual</li></ul><p><strong>（3）隐藏</strong><br>隐藏是指派生类函数将基类函数给屏蔽了，只作用与派生类，其特性与覆盖不同：</p><ol><li>如果派生类的函数与基类的函数名相同，但是参数不同，此时不论有无virtual关键字，基类函数会被隐藏。</li><li>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字，此时，基类的函数被隐藏。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC编译的阶段</title>
      <link href="/2021/05/16/gcc-bian-yi-de-jie-duan/"/>
      <url>/2021/05/16/gcc-bian-yi-de-jie-duan/</url>
      
        <content type="html"><![CDATA[<p><strong>（1）预编译</strong><br>主要处理源代码文件中的以#开头的预编译指令，处理规则如下：</p><ul><li>删除所有的#define，展开所有的宏定义</li><li>处理所有的条件预编译指令，如”#if”、”#endif”、”#ifdef”</li><li>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件</li><li>删除所有的注释，“//”和“/**/”</li><li>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用</li><li>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号</li></ul><p><strong>（2）编译</strong><br>把预编译之后生成的xxx.i或xxx.ii文件，进行==一系列词法分析、语法分析、语义分析及优化==后，生成相应的汇编代码文件</p><ul><li>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号</li><li>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树</li><li>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义</li><li>优化：源代码级别的一个优化过程</li><li>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示</li><li>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等</li></ul><p><strong>(3)  汇编</strong><br>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、xxx.obj(Windows下)</p><p><strong>(4) 链接</strong><br>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：<br>1、静态链接：<br>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快<br>2、动态链接：<br>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型函数和模板</title>
      <link href="/2021/05/15/fan-xing-han-shu-mo-ban/"/>
      <url>/2021/05/15/fan-xing-han-shu-mo-ban/</url>
      
        <content type="html"><![CDATA[<h2 id="一、函数模板"><a href="#一、函数模板" class="headerlink" title="一、函数模板"></a>一、函数模板</h2><h4 id="为什么需要函数模板？"><a href="#为什么需要函数模板？" class="headerlink" title="为什么需要函数模板？"></a>为什么需要函数模板？</h4><p>设计一个交换两个整型变量值的函数：<code>void Swap(int &amp;a, int &amp;b){...}</code><br>设计一个交换两个浮点型变量值的函数：<code>void Swap(double &amp;a, double &amp;b){...}</code><br>其实函数传入参数个数、函数实现的功能和逻辑是类似的，但是因为传入参数的类型不同，需要重新写一个Swap函数，非常冗余<br>此时，可以使用函数模板，来实现兼容各个类型参数的函数</p><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>T 是类型参数，代表类型。编译器由模板自动生成函数时，会用具体的类型名对模板中所有的类型参数进行替换，其他部分则原封不动地保留。同一个类型参数只能替换为同一种类型。编译器在编译到调用函数模板的语句时，会根据实参的类型判断该如何替换模板中的类型参数。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> 参数类型<span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> 参数类型<span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">></span>返回值类型 模板名 <span class="token punctuation">(</span>参数表<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Swap</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> T <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>    T tmp <span class="token operator">=</span> a<span class="token punctuation">;</span>    a <span class="token operator">=</span> b<span class="token punctuation">;</span>    b <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注意得先定义在传参，如果Swap(1, 2)是会报错的</span>    <span class="token keyword">int</span> a1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> a2 <span class="token operator">=</span> <span class="token number">1.5</span><span class="token punctuation">,</span> b2 <span class="token operator">=</span> <span class="token number">3.4</span><span class="token punctuation">;</span>    <span class="token function">Swap</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> b1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Swap</span><span class="token punctuation">(</span>a2<span class="token punctuation">,</span> b2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="函数模板和普通函数"><a href="#函数模板和普通函数" class="headerlink" title="函数模板和普通函数"></a>函数模板和普通函数</h4><ol><li>如果模板函数和普通函数都可以调用，会优先调用普通函数</li><li>可以通过空模板参数列表来强制调用模板函数</li><li>模板函数也可以重载</li><li>如果模板函数可以产生更好的匹配，优先调用函数模板<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p>int myAdd(int a, int b) {<br>    cout &lt;&lt; “调用普通函数” &lt;&lt; endl;<br>    return a + b;<br>}<br>template<class t><br>T myAdd(T a, T b) {<br>    cout &lt;&lt; “调用函数模板” &lt;&lt; endl;<br>    return a + b;<br>}<br>template<class t><br>T myAdd(T a, T b,T c) {<br>    cout &lt;&lt; “调用重载函数模板” &lt;&lt; endl;<br>    return a + b;<br>}<br>int main()  {<br>    int a = 10;<br>    int b = 20;<br>    //1这里调用普通函数<br>    cout &lt;&lt; myAdd(a, b) &lt;&lt; endl;<br>    //2这里调用函数模板<br>    cout &lt;&lt; myAdd&lt;&gt;(a, b) &lt;&lt; endl;<br>    //3这里调用重载函数模板<br>    cout &lt;&lt; myAdd(a, b, 100) &lt;&lt; endl;<br>    //4这里调用函数模板<br>    cout &lt;&lt; myAdd(‘a’, ‘b’) &lt;&lt; endl;</class></class></p><pre><code>return 0;</code></pre><p>}</p><pre><code>## 二、类模板为了多快好省地定义出一批**相似的类**，可以定义类模板，然后由类模板生成不同的类类模板的目的是建立一个通用类，类中的成员数据类型可以不再指定，用一个虚拟的类型来代表，通过**类模板**生成的称为**模板类**#### 类模板的定义```cpptemplate &lt;class 参数类型1, class 参数类型2, ...&gt;class 类模板名{...};</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">></span>    <span class="token comment" spellcheck="true">//声明一个模板，虚拟类型名为T1和T2</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//类模板名为A</span><span class="token keyword">public</span> <span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span>T1 a<span class="token punctuation">,</span> T2 b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        x <span class="token operator">=</span> a<span class="token punctuation">;</span>        y <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//类内定义</span>    T1 <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">///类外定义</span>    T1 <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token operator">:</span>    T1 x<span class="token punctuation">;</span>    T2 y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在类外定义时成员函数的格式:</span><span class="token comment" spellcheck="true">//template &lt;类型参数表></span><span class="token comment" spellcheck="true">//返回值类型 类模板名&lt;类型参数名列表>::成员函数名(参数表){...}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">></span>T1 A<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">></span><span class="token operator">::</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="模板类的实例化"><a href="#模板类的实例化" class="headerlink" title="模板类的实例化"></a>模板类的实例化</h4><pre class="line-numbers language-cpp"><code class="language-cpp">类模板名<span class="token operator">&lt;</span>真实类型参数表<span class="token operator">></span> 对象名<span class="token punctuation">(</span>构造函数实参表<span class="token punctuation">)</span><span class="token punctuation">;</span>A<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">a1</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>A<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">></span> <span class="token function">a2</span><span class="token punctuation">(</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">7.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：同一个类模板的连个模板类是不兼容的：<code>a1 = a2</code>错误</p><h4 id="模板类和派生"><a href="#模板类和派生" class="headerlink" title="模板类和派生"></a>模板类和派生</h4><p>（1）类模板从类模板派生</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 基类 - 类模板</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    T1 v1<span class="token punctuation">;</span> T2 v2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 派生类 - 类模板</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">public</span> A<span class="token operator">&lt;</span>T2<span class="token punctuation">,</span>T1<span class="token operator">></span> <span class="token punctuation">{</span>    T1 v3<span class="token punctuation">;</span> T2 v4<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 派生类 - 类模板</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span><span class="token keyword">public</span> B<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    T v5<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（2）类模板从模板类派生</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T1</span><span class="token punctuation">,</span><span class="token keyword">class</span> <span class="token class-name">T2</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    T1 v1<span class="token punctuation">;</span> T2 v2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">public</span> A<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">double</span><span class="token operator">></span>  <span class="token comment" spellcheck="true">// A&lt;int,double> 模板类</span><span class="token punctuation">{</span>    T v<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（3）类模板从普通类派生</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 基类 - 普通类</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> v1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 派生类 - 类模板</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">public</span> A  <span class="token comment" spellcheck="true">// 所有从B实例化得到的类 ，都以A为基类</span><span class="token punctuation">{</span>     T v<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（4）普通类从模板类派生</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    T v1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">public</span> A<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">double</span> v<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="类模板与静态成员变量"><a href="#类模板与静态成员变量" class="headerlink" title="类模板与静态成员变量"></a>类模板与静态成员变量</h4><p>类模板中可以定义静态成员，那么从该类模板实例化得到的所有类，都包含同样的静态成员<br>类模板里的静态成员初始化的时候，前面要加<code>template&lt;&gt;</code></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 静态成员</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> count <span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> count <span class="token operator">--</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">A</span><span class="token punctuation">(</span> A <span class="token operator">&amp;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> count <span class="token operator">++</span> <span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">PrintCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 静态函数</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span> <span class="token keyword">int</span> A<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">></span> <span class="token keyword">int</span> A<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">::</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="/2021/05/15/lambda-biao-da-shi/"/>
      <url>/2021/05/15/lambda-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="1-匿名函数"><a href="#1-匿名函数" class="headerlink" title="1. 匿名函数"></a>1. 匿名函数</h3><p><code>lambda</code>表达式是C++11中引入的一项新技术，C++通过Lambda来实现<strong>匿名函数</strong>（Lambda表达式就是匿名函数）</p><blockquote><p>匿名函数应用场景广泛，比如有时候需要写一个函数，但是这个函数不会在其他地方再被使用，这时候再定义该函数，就会显得冗余杂乱，这个时候使用匿名函数就可完美解决，同时增加代码可读性。</p></blockquote><p>如果从广义上说，<code>lamdba</code>表达式产生的是<strong>函数对象</strong>。在类中，可以重载函数调用运算符()，此时类的对象可以将具有类似函数的行为，我们称这些对象为函数对象</p><h3 id="2-Lambda表达式定义"><a href="#2-Lambda表达式定义" class="headerlink" title="2. Lambda表达式定义"></a>2. Lambda表达式定义</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">[</span>capture list<span class="token punctuation">]</span> <span class="token punctuation">(</span>params list<span class="token punctuation">)</span> <span class="token keyword">mutable</span> exception<span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">return</span> type <span class="token punctuation">{</span> function body <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>capture list</code>：捕获外部变量列表</li><li><code>params list</code>：形参列表</li><li><code>mutable</code>：用来说是否可以修改值捕获的变量</li><li><code>exception</code>：异常设定</li><li><code>return tyepe</code>：返回类型</li><li><code>function body</code>：函数体<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//1. 最简单的lambda表达式,没有参数</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>  cout<span class="token operator">&lt;&lt;</span><span class="token string">"Hello,World!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>//2. 输入两个int参数,返回值为int<br>[](int a, int b) -&gt; int{<br>    return a + b;<br>};</p><p>//3. lambda可以自动推断函数返回值类型<br>[](int a, int b){<br>    return a + b;<br>};</p><pre><code>### 3. Lambda表达式的使用一般来说，在需要用到匿名函数的场景下，是需要立即执行函数，因此可以如下操作：```cpp//在函数体后跟上输入的参数,此时函数立即执行,result = 3int result = [](int a, int b) -&gt; int{    return a + b;}(1,2);//如果没有参数时要求函数立即执行[]{    cout&lt;&lt;&quot;hello,world&quot;;}();</code></pre><p>但是如果在后续仍需要用到这个匿名函数的情况下，可以如下操作：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> add <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">int</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-捕获外部变量"><a href="#4-捕获外部变量" class="headerlink" title="4. 捕获外部变量"></a>4. 捕获外部变量</h3><p>Lambda表达式可以使用外部变量，但是需要明确指明可以使用哪些外部变量。那么如何指明这些外部变量呢？通过表达式最前面的 [] 来指明可以访问的外部变量。这一过程也被称为Lambda表达式捕获了外部变量。</p><blockquote><p><strong>总结：</strong></p><ul><li>可以使用参数列表中传递的参数</li><li>可以直接访问静态局部变量、全局变量，可以在函数体中对全局变量和局部静态变量修改</li><li>可以使用在捕捉列表里捕捉的外部变量</li><li>不能直接访问非静态局部变量</li></ul></blockquote><p><strong>值捕获：</strong>当外部变量改变时，不会影响Lambda表达式内该变量的值</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出123</span>a <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//仍输出123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>引用捕获：</strong>当外部变量改变时，Lambda表达式内该变量的值也会改变</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>a<span class="token punctuation">]</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出123</span>a <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//输出321</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>隐式捕获：</strong>让编译器推断Lambda表达式需要使用哪些外部变量，这种方式成为隐式捕获。隐式捕获有两种方式：[=]和[&amp;]。[=]表示以值捕获的方式捕获外部变量，[&amp;]表示以引用捕获的方式捕获外部变量。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>隐式捕获：</strong>Lambda表达式可以组合以上几种捕获方式<br>[this]    —-以值的形式捕获this指针<br>[=, &amp;x]  —-变量x以引用形式捕获，其余变量以传值形式捕获<br>[&amp;, x]    —-变量x以值的形式捕获，其余变量以引用形式捕获</p><p><strong>mutable关键字：</strong>Lambda表达式中，如果是以值捕获的方式获取外部变量，那么在表达式内如果修改了该外部变量，就会引发编译出错。这时候使用<code>mutable</code>关键字就可以避免问题，该关键字用以说明表达式可以修改值捕获的外部变量</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//mutable前必须加()</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="5-STL和Lambda"><a href="#5-STL和Lambda" class="headerlink" title="5. STL和Lambda"></a>5. STL和Lambda</h3><ul><li><p><code>for_each</code>：可以改变原有容器中的值</p><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> vec <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">for_each</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>  i <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>count_if</code>：计数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">count_if</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">></span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>sort</code>：自定义排序</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//实现对二维数组的排序,以第[0]维数据为基准</span><span class="token function">sort</span><span class="token punctuation">(</span>envelopes<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> envelopes<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> e1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> e2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> e1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> e2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>e1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> e2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> e1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> e2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用、指针、智能指针</title>
      <link href="/2021/05/15/yin-yong-zhi-zhen-zhi-neng-zhi-zhen/"/>
      <url>/2021/05/15/yin-yong-zhi-zhen-zhi-neng-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h2 id="一、指针和引用的区别"><a href="#一、指针和引用的区别" class="headerlink" title="一、指针和引用的区别"></a>一、指针和引用的区别</h2><ul><li>指针是一个变量，存储的是一个地址；引用是一个别名，和原对象本质上是同一个东西</li><li>指针可以有多级，引用只有一级</li><li>指针可以为空；引用不能为NULL，且在定义时必须进行初始化</li><li>指针在初始化后可以改变指向；引用在初始化之后不可再改变</li><li><code>sizeof(指针)</code>是本指针的大小；<code>sizeof(引用)</code>是引用所指对象的大小</li><li>指针可以指向空值；引用不能指向空值</li><li>指针的定义和初始化可以分开；引用必须在定义时初始化</li><li>指针可以重新指向别的对象；引用一旦初始化之后不可再改变</li></ul><h2 id="二、悬空指针和野指针"><a href="#二、悬空指针和野指针" class="headerlink" title="二、悬空指针和野指针"></a>二、悬空指针和野指针</h2><p>悬空指针：指针所指的内存已经被释放了<br>野指针：指的是没有初始化的指针</p><h2 id="三、浅拷贝和深拷贝"><a href="#三、浅拷贝和深拷贝" class="headerlink" title="三、浅拷贝和深拷贝"></a>三、浅拷贝和深拷贝</h2><p>浅拷贝：浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块内存地址。如果原来的指针所指的资源释放了，那么再释放浅拷贝指针的资源就会出错<br>深拷贝：不仅拷贝值，还开辟出一块新的空间来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响深拷贝得到的值</p><h2 id="四、智能指针⭐️"><a href="#四、智能指针⭐️" class="headerlink" title="四、智能指针⭐️"></a>四、智能指针⭐️</h2><p>智能指针的作用是管理一个指针，因为存在着以下情况：申请的空间在函数结束时忘记释放，造成内存泄露。使用智能指针可以很大程度上地避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，就会自动调用析构函数自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</p><h4 id="（1）shared-ptr"><a href="#（1）shared-ptr" class="headerlink" title="（1）shared_ptr"></a>（1）<code>shared_ptr</code></h4><p><code>std::shared_ptr</code> 是一种智能指针，它能够记录有多少个 <code>shared_ptr</code> 共同指向同一个对象，当最后一个指向该对象的 <code>shared_ptr</code> 释放时，该对象就会自动释放，不需要调用 <code>delete</code><br><em><em><br>**基本操作</em></em></p><pre class="line-numbers language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> sp<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//空智能指针，可以指向类型为T的对象</span>p           <span class="token comment" spellcheck="true">//将p用作一个条件判断，若p指向一个对象，则为true</span><span class="token operator">*</span>p          <span class="token comment" spellcheck="true">//解引用p，获得它所指的对象</span>p<span class="token operator">-</span><span class="token operator">></span>men      <span class="token comment" spellcheck="true">//等同于(*p).men</span>p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//返回p中保存的指针，要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了</span><span class="token function">swap</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//等同于p.swap(q)，交换p和q中的指针</span>make_shared<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化此对象</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token function">p</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//p是q的拷贝，此操作会递增q中的计数器，q中的之好着呢必须能转换为T*</span>p<span class="token operator">=</span>q<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//p和q都是shared_ptr，所保存的指针必须能互相转换，此操作会递减p的引用计数，递增q的引用计数，</span>                        <span class="token comment" spellcheck="true">//若p的引用计数变为0，则将其管理的原内存释放</span>p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//返回与p共享对象的智能指针数量</span>p<span class="token punctuation">.</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//若p.use_count()为1，返回true，否则返回false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>make_shared</code>函数</strong><br>最安全的分配和使用动态内存的方法就是调用<code>make_shared()</code>标准库函数，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code></p><pre class="line-numbers language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sp1 <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//指向一个值为42的int型的shared_ptr</span>shared_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> sp2 <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//指向一个值为“99999”的string</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sp3 <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//指向一个值初始化的int</span><span class="token comment" spellcheck="true">//通常使用auto定义对象来保存make_shared的结果，这种方式更简单</span><span class="token keyword">auto</span> sp4 <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>**shared_ptr**</code><strong>的计数与对象销毁</strong><br>当进行拷贝或赋值操作时，每个<code>shared_ptr</code>都会记录有多少其他<code>shared_ptr</code>指向相同的对象：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">auto</span> p <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> <span class="token function">q</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//p和q指向相同的对象，此对象有两个引用者</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>可以认为每个<code>shared_ptr</code>都有一个关联的计数器，通常称其为<strong>引用计数</strong>，无论何时，只要拷贝一个<code>shared_ptr</code>，计数器都会递增；当给<code>shared_ptr</code>赋予一个新值或是<code>shared_ptr</code>被销毁，计数器就会递减。一旦一个计数器变为0，它就会自动释放自己所管理的对象。</li><li>当指向对象的最后一个<code>shared_ptr</code>被销毁时，<code>shared_ptr</code>类会自动销毁这个对象。这个操作是通过类的析构函数来执行的，<code>shared_ptr</code>的析构函数会递减它所指对象的引用计数，如果引用计数变为0，<code>shared_ptr</code>的析构函数就会摧毁对象，并释放它占用的内存。</li><li>这样一来，动态对象不再被使用时，<code>shared_ptr</code>类就会自动释放动态对象，使得动态内存的使用变得简单</li></ul><p><strong><code>shared_prt</code>和<code>new</code>结合使用</strong><br>我们还可以使用<code>new</code>返回的指针来初始化智能指针：</p><pre class="line-numbers language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">sp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//sp指向一个值为42的int</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此处需要注意的是，接收指针参数的智能指针构造函数是<strong>explicit</strong>的，因此无法进行隐式转换，必须使用直接初始化形式：</p><pre class="line-numbers language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//错误，无法进行隐式转换（*int转换成shared_ptr）</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//正确，直接初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是还是推荐使用<code>make_shared()</code>而不是<code>new</code>，因为这样在分配对象的同时就能将<code>shared_ptr</code>与之绑定，从而避免了将同一块内存绑定到多个独立创建的<code>shared_ptr</code>上</p><p><strong>定义和改变<code>shared_prt</code>的其他方法</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp">shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//p管理内置指针q所指向的对象；q必须指向new分配的内存，且能够转换为T*类型</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//p从unique_ptr u哪里接管了对象的所有权，将u置为空</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">p</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//p接管了内置指针q所指向的对象的所有权，q必须能转换为T*类型，p将使用可调用对象d</span>                                             <span class="token comment" spellcheck="true">//来代替delete</span>p<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//若p是唯一指向其对象的shared_ptr，reset会释放此对象</span>p<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//若传递了参数内置指针q，会令p指向q，否则会把p置为空</span>p<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//若还传递了参数d，将会调用d而不是delete来释放q</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（2）unique-pr"><a href="#（2）unique-pr" class="headerlink" title="（2）unique_pr"></a>（2）<code>unique_pr</code></h4><p><code>unique_prt</code>实现独占式拥有、严格拥有概念，保证同一时间只能有一个智能指针可以指向该对象。当<code>unique_prt</code>离开作用域，指针所指的内存空间就会被释放</p><p>在下列两者之一发生时用关联的删除器释放对象：</p><ul><li><p>销毁了管理的<code>unique_ptr</code>对象</p></li><li><p>通过<code>operator =</code>或<code>reset()</code>赋值另一指针给管理的<code>unique_ptr</code></p></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> up<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//空智能指针，可以指向类型T的对象</span>p           <span class="token comment" spellcheck="true">//将p用作一个条件判断，若p指向一个对象，则为true</span><span class="token operator">*</span>p          <span class="token comment" spellcheck="true">//解引用p，获得它所指的对象</span>p<span class="token operator">-</span><span class="token operator">></span>men<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//等同于(*p).men</span>p<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//返回p中保存的指针，要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了</span><span class="token function">swap</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//交换p和q中的指针，等同于p.swap(q)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与<code>shared_ptr</code>不同，<code>unique_ptr</code>没有类似<code>make_shared</code>的标准库函数返回一个<code>unique_ptr</code>。当定义一个<code>unique_ptr</code>时，需要将其绑定到一个<code>new</code>返回的指针上，类似<code>shared_ptr</code>，初始化<code>unique_ptr</code>必须采用直接初始化的方法：</p><pre class="line-numbers language-cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> p1<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//指向一个string的unique_ptr</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//指向一个值为42的int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于<code>unique_ptr</code>拥有它指向的对象，因此<code>unique_ptr</code><strong>不支持普通的拷贝或赋值操作：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"aoligei"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//错误，unique_ptr不支持拷贝</span>unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> p3<span class="token punctuation">;</span>p3 <span class="token operator">=</span> p1<span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//错误，unique_ptr不支持赋值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>unique_ptr支持的操作：</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> u1<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//空unique_ptr，可以指向类型为T的对象</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>D<span class="token operator">></span> u2<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//u1会使用delete来释放指针，u2会使用一个类型为D的可调用对象来释放它的指针</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>D<span class="token operator">></span> <span class="token function">u</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//空unique_ptr，指向类型为T的对象，用类型为D的对象d来代替delete</span>u <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//释放u指向的对象，将u置为空</span>u<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//u放弃对指针的控制权，返回指针，并将u置为空</span>u<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//释放u指向的对象</span>u<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//如果提供了内置指针q，令u指向这个对象，否则将u置为空</span>u<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虽然不能对<code>unique_ptr</code>进行拷贝或赋值，但是可以通过调用<code>release()</code>和<code>reset()</code>将指针的所有权从一个<code>unique_ptr</code>转移到另一个<code>unique_ptr</code>：</p><pre class="line-numbers language-cpp"><code class="language-cpp">unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//将所有权从p1转移到p2，p1置为空</span>p2<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>p3<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//将所有权从p3转移到p2，reset释放了p2原来指向的内存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另外有一个特例，可以赋值或拷贝一个将要被销毁的<code>unique_ptr</code>，典型的例子就是<code>unique_ptr</code>作为函数的返回值。编译器知道要返回的对象将要别销毁，在此情况下，编译器会执行一种特殊的拷贝。</p><h4 id="（3）-weak-pt"><a href="#（3）-weak-pt" class="headerlink" title="（3） weak_pt"></a>（3） <code>weak_pt</code></h4><p><code>weak_ptr</code>是一种不控制所指对象生存期的智能指针，它指向由一个<code>shared_ptr</code>管理的对象。将一个<code>weak_ptr</code>绑定到一个<code>shared_ptr</code>不会改变<code>shared_ptr</code>的引用计数。一旦最后一个指向对象的<code>shared_ptr</code>被销毁，对象就会被释放，即使有<code>weak_ptr</code>指向对象，对象也还是会被销毁，因此<code>weak_ptr</code>的名字抓住了这种智能指针“弱”共享对象的特点。</p><h4 id="（4）auto-ptr"><a href="#（4）auto-ptr" class="headerlink" title="（4）auto_ptr"></a>（4）<code>auto_ptr</code></h4><p>  在C++17里已经被移除了，不谈。</p><h4 id="（5）智能指针的实现"><a href="#（5）智能指针的实现" class="headerlink" title="（5）智能指针的实现"></a>（5）智能指针的实现</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">namespace</span> smart <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 引用计数类.</span>    <span class="token keyword">class</span> <span class="token class-name">smart_count</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token function">smart_count</span><span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">use_count</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token operator">~</span><span class="token function">smart_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 增加引用计数, 并返回计数值.</span>        <span class="token keyword">int</span> <span class="token function">addref</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">++</span>use_count<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 减少引用计数, 并返回计数值.</span>        <span class="token keyword">int</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">--</span>use_count<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        <span class="token comment" spellcheck="true">// 计数变量.</span>        <span class="token keyword">int</span> use_count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 智能指针.</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span>    <span class="token keyword">class</span> <span class="token class-name">smart_ptr</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token comment" spellcheck="true">// 构造指针, 并使引用计数置为1.</span>        <span class="token keyword">explicit</span> <span class="token function">smart_ptr</span><span class="token punctuation">(</span>T <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">p</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">smart_count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 构造空指针.</span>        <span class="token keyword">explicit</span> <span class="token function">smart_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">u</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 智能指针析构.</span>        <span class="token operator">~</span><span class="token function">smart_ptr</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果引用计数等于0, 则删除数据和引用计数, 并置p为NULL.</span>            <span class="token comment" spellcheck="true">// 此处需要注意的是, 共用的u并未置为 NULL, 在其它指针析构</span>            <span class="token comment" spellcheck="true">// 时, p为NULL, 则不会重复delete.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> u<span class="token operator">-</span><span class="token operator">></span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">delete</span> p<span class="token punctuation">;</span>                <span class="token keyword">delete</span> u<span class="token punctuation">;</span>                p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 智能指针拷贝构造函数.</span>        <span class="token function">smart_ptr</span><span class="token punctuation">(</span><span class="token keyword">const</span> smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> t<span class="token punctuation">.</span>p<span class="token punctuation">;</span>            u <span class="token operator">=</span> t<span class="token punctuation">.</span>u<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>u<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 必须判断空值.</span>            <span class="token punctuation">{</span>                u<span class="token operator">-</span><span class="token operator">></span><span class="token function">addref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 增加引用计数.</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 指针赋值.</span>        smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 增加引用计数.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span>u<span class="token operator">-</span><span class="token operator">></span><span class="token function">addref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            T <span class="token operator">*</span>temp_p <span class="token operator">=</span> p<span class="token punctuation">;</span>            smart_count <span class="token operator">*</span>temp_u <span class="token operator">=</span> u<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 直接赋值.</span>            p <span class="token operator">=</span> t<span class="token punctuation">.</span>p<span class="token punctuation">;</span>            u <span class="token operator">=</span> t<span class="token punctuation">.</span>u<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>temp_p <span class="token operator">&amp;&amp;</span> temp_u<span class="token operator">-</span><span class="token operator">></span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">delete</span> temp_p<span class="token punctuation">;</span>                <span class="token keyword">delete</span> temp_u<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 返回当前smart_ptr指针.</span>            <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重载->操作和*操作符.</span>        T <span class="token operator">*</span><span class="token keyword">operator</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span>        T <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重载!操作符.</span>        <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span>p<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重载指针bool值操作符.</span>        <span class="token keyword">typedef</span> smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> this_type<span class="token punctuation">;</span>        <span class="token keyword">typedef</span> T <span class="token operator">*</span>this_type<span class="token operator">::</span><span class="token operator">*</span>unspecified_bool_type<span class="token punctuation">;</span>        <span class="token keyword">operator</span> <span class="token function">unspecified_bool_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span>p <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token operator">&amp;</span>this_type<span class="token operator">::</span>p<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 得到原指针.</span>        T <span class="token operator">*</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span>T <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            T <span class="token operator">*</span>temp_p <span class="token operator">=</span> p<span class="token punctuation">;</span>            smart_count <span class="token operator">*</span>temp_u <span class="token operator">=</span> u<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 赋值, 如果是NULL, 则不创建引用计数.</span>            p <span class="token operator">=</span> ptr<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>                u <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">smart_count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                u <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>temp_p <span class="token operator">&amp;&amp;</span> temp_u<span class="token operator">-</span><span class="token operator">></span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">delete</span> temp_p<span class="token punctuation">;</span>                <span class="token keyword">delete</span> temp_u<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 增加引用计数.</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span>u<span class="token operator">-</span><span class="token operator">></span><span class="token function">addref</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            T <span class="token operator">*</span>temp_p <span class="token operator">=</span> p<span class="token punctuation">;</span>            smart_count <span class="token operator">*</span>temp_u <span class="token operator">=</span> u<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 赋值.</span>            p <span class="token operator">=</span> t<span class="token punctuation">.</span>p<span class="token punctuation">;</span>            u <span class="token operator">=</span> t<span class="token punctuation">.</span>u<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>temp_p <span class="token operator">&amp;&amp;</span> temp_u<span class="token operator">-</span><span class="token operator">></span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">delete</span> temp_p<span class="token punctuation">;</span>                <span class="token keyword">delete</span> temp_u<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token keyword">private</span><span class="token operator">:</span>        T <span class="token operator">*</span>p<span class="token punctuation">;</span>        smart_count <span class="token operator">*</span>u<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 重载==操作符.</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span>    <span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 重载!=操作符.</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">></span>    <span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span>smart_ptr<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> smart_ptr<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>右值和转移语义</title>
      <link href="/2021/05/15/you-zhi-he-zhuan-yi-yu-yi/"/>
      <url>/2021/05/15/you-zhi-he-zhuan-yi-yu-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、左值和右值"><a href="#一、左值和右值" class="headerlink" title="一、左值和右值"></a>一、左值和右值</h2><p><strong>左值</strong>：它表示一个可被标识的（变量或对象的）内存位置，并且允许使用&amp;操作符来获取这块内存的地址<br><strong>右值</strong>：如果一个表达式不是左值，那就是右值</p><blockquote><p>也有解释：<br>左值是可以位于赋值运算符<code>=</code>左侧的表达式<br>右值是不可以位于赋值运算符<code>=</code>左侧的表达式</p></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp">x <span class="token operator">=</span> y<span class="token punctuation">;</span>y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// x 和 y 都是左值</span>z <span class="token operator">=</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// z 是左值，x * y是右值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>左值引用</strong>：对一个左值进行引用的类型，声明符号为”&amp;”<br><strong>右值引用</strong>：对一个右值进行引用的类型，声明符号为”&amp;&amp;”，右值通常不具有名字，因此只能通过引用的方式找到它的存在</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//左值引用</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>x <span class="token operator">=</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//右值引用</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>y <span class="token operator">=</span> b<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//也可以用const的左值引用来绑定一个右值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>右值引用的意义：</p><ul><li><p>为临时变量续命，右值会在表达式结束后消亡，如果继续使用右值，就会调用昂贵的拷贝构造函数</p></li><li><p>右值引用是用来支持转移语义的，通过转移语义，临时对象中的资源能够转移到其他对象里（转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多）</p></li></ul><h2 id="二、转移语义"><a href="#二、转移语义" class="headerlink" title="二、转移语义"></a>二、转移语义</h2><p>转移语义可以将资源从一个对象转移到另一个对象，这样就能减少不必要的临时对象的拷贝和销毁，能够大幅提高C++应用程序的性能。<br>通过转移语义，可以将临时对象的资源转移到其他对象里。在之前的C++机制中，关于对象的操作，只有新建（赋值构造函数、赋值运算符），拷贝（拷贝构造函数、拷贝复制运算符）。如果要实现对象资源的转移，即实现转移语义，需要通过实现转移构造函数或转移赋值操作符。</p><blockquote><p><strong>注意：</strong></p><ul><li>参数（右值）的符号必须是右值引用符号，即“&amp;&amp;”</li><li>参数（右值）不可以是常量，因为我们需要修改右值</li><li>参数（右值）的资源链接和标记必须修改。否则右值的析构函数就会释放资源。转移到新对象的资源也就无效了</li></ul></blockquote><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">person</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">//普通构造函数</span>    <span class="token function">person</span><span class="token punctuation">(</span><span class="token keyword">int</span> Age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">{</span>age <span class="token operator">=</span> Age<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//拷贝构造函数</span>    <span class="token function">person</span><span class="token punctuation">(</span><span class="token keyword">const</span> person <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>age <span class="token operator">=</span> p<span class="token punctuation">.</span>age<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//赋值运算符</span>    person <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> person <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>            age <span class="token operator">=</span> p<span class="token punctuation">.</span>age<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//转移构造函数</span>    <span class="token function">person</span><span class="token punctuation">(</span>person <span class="token operator">&amp;&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>        age <span class="token operator">=</span> p<span class="token punctuation">.</span>age<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//链接资源的标记必须修改，否则当临时对象析构时转移到新对象的资源无效</span>        p<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//转移运算符</span>    person <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>person <span class="token operator">&amp;&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span>            age <span class="token operator">=</span> p<span class="token punctuation">.</span>age<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//链接资源的标记必须修改，否则当临时对象析构时转移到新对象的资源无效</span>            p<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mian</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果用户没有定义，编译器会自动生成拷贝构造函数和赋值运算符</span>    person <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//普通构造函数</span>    person <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//拷贝构造函数</span>    person p3<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//赋值运算符</span>    p3 <span class="token operator">=</span> p1<span class="token punctuation">;</span>    person <span class="token function">p4</span><span class="token punctuation">(</span><span class="token function">person</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//转移构造函数</span>    person p5<span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">//转移运算符</span>    p5 <span class="token operator">=</span> <span class="token function">person</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong><br>临时对象通过一个接受右值的函数传递给另一个函数时就会变成左值，因为传递过程中临时对象变成了命名对象 </p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//接受左值 </span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"left value print:"</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>i<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//接受有值 </span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"right value print:"</span><span class="token operator">&lt;&lt;</span>i<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">forward_value</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//临时对象通过一个接受右值的函数传递给另一个函数时就会变成左值，因为传递过程中</span>    <span class="token comment" spellcheck="true">//临时对象变成了命名对象 </span>    <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>std::move</code></strong><br>所有的命名对象都是左值引用，而编译器只对右值引用才会调用转移语义。如果能够确定一个命名对象将不再被使用，就可以对它调用转移语义，也就是把一个左值当作右值引用来使用。为了实现这种用法，C++标准库提供了函数<code>std::move</code>，这个函数==将左值引用转为右值引用==。</p><h2 id="三、精准传递"><a href="#三、精准传递" class="headerlink" title="三、精准传递"></a>三、精准传递</h2><p>C++中，除了参数值和参数类型外，还有两组属性：左值/右值、const和非const<br>精准传递就是在参数传递过程中，参数的值和这些属性都不能改变。在泛型函数中，这样的要求非常普遍。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">forward_value</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">process_value</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">></span><span class="token keyword">void</span> <span class="token function">forward_value</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">process_value</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，尽管已经是模板函数，可以泛化到各个类型的参数，但是对于具有不同属性（const/非const、左值/右值）的参数，仍需要通过重载函数来实现。怎么说呢，这就是泛化地不够彻底。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">></span><span class="token keyword">void</span> <span class="token function">forward_value</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">process_value</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示：可以通过右值引用来实现精准传递。只需要定义一次，接受一个右值引用的参数，就能够将所有的参数类型原封不动的传递给目标函数，参数的左右值属性和 const/non-cosnt 属性完全传递给目标函数 process_value。</p><blockquote><p>C++11 中定义的 T&amp;&amp; 的推导规则为：右值实参为右值引用，左值实参仍然为左值引用。一句话，就是参数的属性不变。这样也就完美的实现了参数的完整传递。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new/delete和malloc/free</title>
      <link href="/2021/05/14/new-delete-he-malloc-free/"/>
      <url>/2021/05/14/new-delete-he-malloc-free/</url>
      
        <content type="html"><![CDATA[<p><code>malloc/free</code><br>需要动态开辟内存时，可以使用<code>malloc/free</code>函数，从堆中获得空间，即<code>malloc</code>函数返回指向堆里面一块内存的指针。操作系统中有一个记录空闲内存地址的链表，如果收到获取内存空间的请求，就会遍历这个链表，找到第一个空间大于申请空间的堆结点，然后将该节点从链表中删除，并返回指向该空间的指针。在使用malloc分配内存空间后，一定要使用<code>free()</code>函数释放内存空间，否则就会内存泄露。另外，<code>free()</code>释放的是内存空间，并没有释放指向该空间的指针，如果不在释放内存后将该指针指向NULL，就会形成悬空指针</p><p><code>new/delete</code><br><code>new/delete</code>是操作符，与+、-类似，可以用于申请动态内存和动态内存释放</p><ul><li>当使用new动态申请内存时：首先调用operator new标准库函数，据说这个标准库函数的底层实际上还是malloc，传入的参数为目标对象的大小；此时申请到的内存时未初始化的，接着就在这块内存上调用相应的构造函数；最后一步返回新分配并构造好的对象的指针</li><li>当使用delete释放内存时：调用对象的析构函数，然后调用operator delete标准库函数来释放该内存，同样据说这个标准库函数的底层实际上是free，传入的参数为对象的地址值</li></ul><p><strong>二者的区别</strong><br><strong>本质区别</strong>：<code>new/delete</code>是操作符；<code>malloc/free</code>是标准库函数<br><strong>操作对象范围不同：</strong></p><ul><li><code>malloc/free</code>是标准库函数，编译器不会对其进行编译检查，仅仅具有分配和释放内存空间功能，不具备调用构造函数和析构函数的功能，因此用<code>malloc</code>分配空间存储类的对象存在风险</li><li><code>new/delete</code>除了分配和释放内存空间的功能外，还会调用构造函数和拷贝函数</li></ul><p><strong>其他不同：</strong></p><ul><li><code>new</code>自动计算要分配空间的大小，<code>malloc</code>需要手工计算</li><li><code>malloc/free</code>返回的都是void类型指针，需要进行类型转换；<code>new/delete</code>返回的是具体类型指针</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存对齐</title>
      <link href="/2021/05/14/nei-cun-dui-qi/"/>
      <url>/2021/05/14/nei-cun-dui-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h2><blockquote><p>位：bit；字节：B/Byte；8bit = 1B<br><code>sizeof</code>：用于判断数据类型或表达式长度，这不是一个函数，而是一个关键字，字节数的计算在程序编译时进行，而不是在程序执行过程中才计算出来</p></blockquote><h2 id="二、什么是内存对齐？"><a href="#二、什么是内存对齐？" class="headerlink" title="二、什么是内存对齐？"></a>二、什么是内存对齐？</h2><p>理论上，32位系统下，一个int占4B，一个char占1B，把它们放到一个结构体中，理论上应该是5B，但是实际上运行得到的结果是8B<br>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的<strong>首地址</strong>的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。</p><h2 id="三、为什么要内存对齐？"><a href="#三、为什么要内存对齐？" class="headerlink" title="三、为什么要内存对齐？"></a>三、为什么要内存对齐？</h2><p>尽管内存是以字节为单位的，但是大部分处理器并不是按字节块来存取内存的，它一般会以4字节、8字节、16字节，甚至32字节来存取内存，这称为内存存取粒度<br>对于未对齐的内存，处理器需要两次内存访问，而对齐的内存只需一次内存访问</p><blockquote><ul><li>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的连续四个字节地址中，该处理器去取数据时，要先从0地址开始<strong>读取第一个4字节块</strong>,剔除不想要的字节（0地址）,然后从地址4开始<strong>读取第二个4字节块</strong>，同样剔除不要的数据（5，6，7地址），最后留下的两块数据合并放入寄存器。这需要两次内存访问</li><li>现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</li></ul></blockquote><h2 id="四、内存对齐规则："><a href="#四、内存对齐规则：" class="headerlink" title="四、内存对齐规则："></a>四、内存对齐规则：</h2><p><strong>基本类型的对齐值就是其sizeof值</strong></p><pre class="line-numbers language-cpp"><code class="language-cpp">cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1</span>cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>结构struct或联合union的数据成员的对齐规则：</strong><br><strong>有效对齐值/对齐单位</strong>：给定的#pragma pack(n)和结构体中最长数据类型，二者中长度较小的长度，称为有效对齐值，也叫对齐单位<br>结构体和联合体在内存中的分配都是连续的，其首地址就是第一个数据成员的地址，用<code>offset</code>来表示数据成员的地址到结构体初始地址的距离。<br>第一个数据成员的<code>offset = 0</code>，之后的数据成员的<code>offset</code>为<strong>该数据成员的大小**</strong>与<strong>**对齐单位</strong>二者中较小值的整数倍</p><blockquote><p>这句话的理解非常重要：所以当两个<code>char</code>连续存储时，不会是4+4，而是一起占用一个4</p></blockquote><p>如果没有对齐，在对齐时就会在这个成员后填充空子节使得数据成员对齐</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">char</span> a<span class="token punctuation">;</span>    <span class="token keyword">char</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token keyword">char</span> d<span class="token punctuation">;</span><span class="token punctuation">}</span>s<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//输出12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>linux下默认#pragma pack(4)</p><ol><li>sizeof(a) = 1 &lt; 对齐单位，按照1字节对齐，占用offset = 0的位置</li><li>sizeof(b) = 1 &lt; 对齐单位，按照1字节对齐，占用offset = 1的位置</li><li>sizeof(c) = 4 = 对齐单位，按照4字节对齐，占用offset = 4的位置</li><li>sizeof(d) = 1 &lt; 对齐单位， 按照1字节对齐，占用offset = 8的位置</li></ol></blockquote><p><strong>整体对齐：</strong><br>数据成员对齐之后，还需要整体对齐，数据对齐时<code>struct</code>的大小需为<strong>对齐单位</strong>的整数倍，则需要添加空子节；因此原因，数据成员存放顺序会影响结构体的大小，大成员往后放</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载</title>
      <link href="/2021/05/12/yun-suan-fu-chong-zai/"/>
      <url>/2021/05/12/yun-suan-fu-chong-zai/</url>
      
        <content type="html"><![CDATA[<p>C++中预定义的运算法，通常只能用于基本数据类型间的计算，而不能用于对象之间的运算。为了能在对象间运用运算符，就需要重载运算符</p><blockquote><p>比如说有一个复数类，该类有两个成员变量，对应实部和虚部<br>通过重载 <code>+</code> 运算符，实现复数类对象的求和</p></blockquote><p>运算符重载的实值就是函数重载，可以重载为普通函数，也可以重载为成员函数，运算符重载的基本形式如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp">返回值类型 <span class="token keyword">operator</span> 运算符<span class="token punctuation">(</span>形参表<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token comment" spellcheck="true">// 复数类</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">// 构造函数，如果不传参数，默认把实部和虚部初始化为0</span>    <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> i <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_real</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_imag</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 重载-号运算符，属于成员函数</span>    Complex <span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 返回一个临时对象</span>        <span class="token keyword">return</span> <span class="token function">Complex</span><span class="token punctuation">(</span>m_real <span class="token operator">-</span> c<span class="token punctuation">.</span>m_real<span class="token punctuation">,</span> m_imag <span class="token operator">-</span> c<span class="token punctuation">.</span>m_imag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 打印复数</span>    <span class="token keyword">void</span> <span class="token function">PrintComplex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> m_real <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> m_imag <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 将重载+号的普通函数，定义成友元函数</span>    <span class="token comment" spellcheck="true">// 目的是为了友元函数能访问对象的私有成员</span>    <span class="token keyword">friend</span> Complex <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">double</span> m_real<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 实部的值</span>    <span class="token keyword">double</span> m_imag<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 虚部的值</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 重载+号运算符，属于普通函数，不是对象的成员函数</span>Complex <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 返回一个临时对象</span>    <span class="token keyword">return</span> <span class="token function">Complex</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>m_real <span class="token operator">+</span> b<span class="token punctuation">.</span>m_real<span class="token punctuation">,</span> a<span class="token punctuation">.</span>m_imag <span class="token operator">+</span> b<span class="token punctuation">.</span>m_imag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Complex <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Complex <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Complex c<span class="token punctuation">;</span>    c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等价于c = operator+(a,b)</span>    c<span class="token punctuation">.</span><span class="token function">PrintComplex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c <span class="token operator">=</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等价于 c = a.operator-(b)</span>    c<span class="token punctuation">.</span><span class="token function">PrintComplex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得注意的是：在重载函数中，传入参数是<code>const Complex &amp;a</code>常引用类型，主要是为了减少拷贝带来的开销，同时又不希望重载函数对原对象进行修改</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存模型</title>
      <link href="/2021/05/11/nei-cun-mo-xing/"/>
      <url>/2021/05/11/nei-cun-mo-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="一、内存模型"><a href="#一、内存模型" class="headerlink" title="一、内存模型"></a>一、内存模型</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2897574/1617068107210-b69e8cd7-9fc6-4215-aaa4-2624907df5f0.png#align=left&display=inline&height=398&margin=%5Bobject%20Object%5D&originHeight=796&originWidth=1218&size=0&status=done&style=none&width=609" alt="内存模型"></p><p><strong>用户空间</strong><br><strong>（1）堆：</strong>由程序员手动分配和释放，完全不同于数据结构中的堆，分配方式类似链表。由malloc或new来分配，由free或delete释放。如果程序员不释放，程序结束时由系统释放。<br><strong>（2）栈：</strong>由编译器自动分配和释放，存放函数的参数值、局部变量的值等。操作方式类似数据结构中的栈。<br><strong>（3）全局（静态）存储区：</strong>存放全局变量和静态变量。包括两部分：DATA段（全局初始化区）和BSS段（全局未初始化区）。初始化后的全局变量和静态变量存放在DATA段，未初始化的全局变量和未初始化的静态变量存放在BSS段。程序结束后由系统释放。另外，BSS段在程序执行之前会自动清0，因此未初始化的全局变量和静态变量在程序执行之前会变成0。<br><strong>（4）常量区：</strong>常量字符串就是放在这里，程序结束后由系统释放，属于全局(静态)存储区<br><strong>（5）文本/程序代码区：</strong>存放函数体的二进制代码，并且是只读的</p><blockquote><p>对于整数类型，如果出现在表达式语句中，通常会成为“立即数”，被包含在生成的代码中。<br>没有参与代码生成的常量，比如用于全局变量的初始化、数组声明、模板参数等等，哪里也不存，在编译期就处理了。<br>其它常量，通常放在静态数据区。</p></blockquote><p><strong>内核空间</strong><br>内核空间占高地址的1G，是所有进程共享的，而用户空间是每个进程私有的<br>进程在运行的时候，在内核空间和用户空间各有一个堆栈。运行在用户空间时，进程使用的是用户空间中的堆栈，称为用户态；运行在内核空间时，进程使用的是内核空间中的堆栈，称为内核态</p><h2 id="二、堆和栈比较"><a href="#二、堆和栈比较" class="headerlink" title="二、堆和栈比较"></a>二、堆和栈比较</h2><table><thead><tr><th align="center"></th><th align="center">堆</th><th align="center">栈</th></tr></thead><tbody><tr><td align="center">管理方式</td><td align="center">由程序员申请和释放</td><td align="center">系统自动分配</td></tr><tr><td align="center">内存管理机制</td><td align="center">系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序</td><td align="center">只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。</td></tr><tr><td align="center">空间大小</td><td align="center">堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大</td><td align="center">栈是一块连续的内存区域，大小是操作系统预定好的</td></tr><tr><td align="center">碎片问题</td><td align="center">对于堆，频繁的new/delete会造成大量碎片，使程序效率降低</td><td align="center">对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片</td></tr><tr><td align="center">生长方向</td><td align="center">堆向上，向高地址方向增长</td><td align="center">栈向下，向低地址方向增长</td></tr><tr><td align="center">分配方式</td><td align="center">动态分配</td><td align="center">静态分配+动态分配</td></tr><tr><td align="center">分配效率</td><td align="center">低</td><td align="center">高</td></tr></tbody></table><p>常问总结：</p><ul><li>申请方式不同：堆是由程序员申请和释放的；栈是操作系统自动分配的</li><li>申请效率不同：堆由程序员分配，速度慢，会有碎片；栈由系统分配，速度快，没有碎片</li><li>申请空间不同：32位系统下，堆内存可以达到4G；栈默认为2M</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类型转换</title>
      <link href="/2021/05/10/lei-xing-zhuan-huan/"/>
      <url>/2021/05/10/lei-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<blockquote><p>C++中，类型转换分为两种：隐式类型转换和显式类型转换</p></blockquote><h2 id="一、隐式类型转换"><a href="#一、隐式类型转换" class="headerlink" title="一、隐式类型转换"></a>一、隐式类型转换</h2><p>隐式类型转换是编译器自动执行的，无需显式的操作符。隐式类型转换往往是安全的，并且带来了便捷：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">2.5</span><span class="token punctuation">;</span>a <span class="token operator">+</span> b<span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//a会被隐式转换成double类型</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//1被隐式转换成了double类型1.0</span><span class="token keyword">double</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//运算结果会被隐式转换成double类型返回</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span><span class="token keyword">public</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>B b<span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//子类对象替代父类对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这种隐式转换也存在着风险，一般要满足低精度转换成高精度，否则就会造成精度损失<br>Google在C++编程规范中建议：可接受单个参数的构造函数必须加上<code>explicit</code>标记，禁止隐式类型转换</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">student</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">explicit</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、显式类型转换"><a href="#二、显式类型转换" class="headerlink" title="二、显式类型转换"></a>二、显式类型转换</h2><p>C风格的显式类型转换如下，但是不推荐使用，转化不明确，不能进行错误检查，容易出错。C++提供了4种强制类型转换操作符。</p><pre class="line-numbers language-cpp"><code class="language-cpp">TypeName x <span class="token operator">=</span> <span class="token punctuation">(</span>TypeName<span class="token punctuation">)</span> y<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//C风格的显式转换（不推荐使用）</span>cast_name<span class="token operator">&lt;</span>type<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//C++风格的类型转换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="1-static-cast"><a href="#1-static-cast" class="headerlink" title="1. static_cast"></a>1. static_cast</h4><p>编写程序时需要明确的类型转换都可以使用static_cast，但是static_cast不能转换掉底层const，volatile和__unaligned属性。另外由于不提供运行时的检查，因此需要在编写程序时确认转换的安全性。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static_cast</span> <span class="token operator">&lt;</span>new_type<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//使用方法</span><span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">3.14159</span><span class="token punctuation">;</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//一般来说，编译器隐式类型转换都可以用static_cast来转换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用场景：</strong></p><ol><li>用于类层次结构中，父类和子类之间指针和引用的转换；进行上行转换，把子类对象的指针/引用转换为父类指针/引用，这种转换是安全的；进行下行转换，把父类对象的指针/引用转换成子类指针/引用，因为没有有运行时类型检查来保证转换的安全性，这种转换是不安全的，需要编写程序时来确认</li><li>用于基本数据类型之间的转换，例如把int转char，int转enum等，需要编写程序时来确认安全性</li><li>把void指针转换成目标类型的指针（这是极其不安全的）</li></ol><h4 id="2-const-cast"><a href="#2-const-cast" class="headerlink" title="2. const_cast"></a>2. const_cast</h4><p>const_cast用于移除类型的const、volatile和_unaligned属性，其中new_type必须是一个指针、引用。只有用const_cast才能移除const性质。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const_cast</span> <span class="token operator">&lt;</span>new_type<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用方法，new_type必须为指针或引用</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pc<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">const_cast</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用场景：</strong></p><ol><li>常量指针被转换成非常量指针，并且仍然指向原来的对象</li><li>常量引用被转换成非常量引用，并且仍然引用原来的对象</li></ol><h4 id="3-reinterpret-cast"><a href="#3-reinterpret-cast" class="headerlink" title="3. reinterpret_cast"></a>3. <strong>reinterpret_cast</strong></h4><p>功能非常强大，万物皆可转，如int转指针，但是容易出问题，建议少用</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>new_type<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//使用方法</span><span class="token keyword">int</span> <span class="token operator">*</span>ip<span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>pc <span class="token operator">=</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-dynamic-cast"><a href="#4-dynamic-cast" class="headerlink" title="4. dynamic_cast"></a>4. dynamic_cast</h4><p>dynamic_cast只能用于有虚函数的类，<strong>dynamic_cast涉及运行时类型检查</strong>，具有一定的安全性，如果使用的类没有虚函数，如果绑定到引用或指针的对象的类型不是目标类型，都会出错。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//new_type必须为类的指针、类的引用、void*</span><span class="token comment" spellcheck="true">//如果new_type是指针类型，expression也必须是指针；new_type是引用，expression也必须是引用</span><span class="token keyword">dynamic_cast</span> <span class="token operator">&lt;</span>new_type<span class="token operator">></span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>使用场景：</strong></p><ol><li><p>上行转换：子类向父类转换，非常安全</p></li><li><p>下行转换：父类向子类转换</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token keyword">public</span> A<span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  A<span class="token operator">*</span> pA <span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>  B<span class="token operator">*</span> pB <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pA<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>void<em>转换：有时候需要将指针转换为void</em>，在适合的时候将void*转换成目标类型指针</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  A <span class="token operator">*</span>pA <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token operator">*</span>pV <span class="token operator">=</span> <span class="token keyword">dynamic_cast</span><span class="token operator">&lt;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">(</span>pA<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常见关键字</title>
      <link href="/2021/05/10/chang-yong-guan-jian-zi/"/>
      <url>/2021/05/10/chang-yong-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Const关键字"><a href="#一、Const关键字" class="headerlink" title="一、Const关键字"></a>一、Const关键字</h2><h4 id="（1）基本数据类型和const"><a href="#（1）基本数据类型和const" class="headerlink" title="（1）基本数据类型和const"></a>（1）基本数据类型和const</h4><ul><li>const修饰对象，表示该对象的值不可变</li><li>const的对象是文件局部变量，只能用于本编译模块，使用extern const声明常量可以作用与其他编译模块，即被其他文件访问<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">extern</span> <span class="token keyword">const</span> <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//extern用于告诉编译器存在着一个变量或者函数，当前编译语句前如果没有定义的话，那么该变量或者函数定义在文件的后头或者其它文件中，即提示编译器遇到此变量和函数时在其他模块中寻找其定义。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="（2）指针与const"><a href="#（2）指针与const" class="headerlink" title="（2）指针与const"></a>（2）指针与const</h4></li></ul><ol><li>常量指针：指针所指对象是一个常量，其值不可变。<code>int const *p</code>、<code>const int *p</code></li><li>指针常量：指针本身是一个常量，不可指向其他对象。<code>int *const p</code></li><li>二者都不变：<code>const int *const p</code></li></ol><h4 id="（3）引用与const"><a href="#（3）引用与const" class="headerlink" title="（3）引用与const"></a>（3）引用与const</h4><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//一般引用无法绑定到字面值常量,const引用可以</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//错误</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//正确</span><span class="token comment" spellcheck="true">//一般引用不能绑定右值，const引用可以</span><span class="token keyword">int</span> var1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> var2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> var1 <span class="token operator">+</span> var2<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//错误</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b <span class="token operator">=</span> var1 <span class="token operator">+</span> var2<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//正确</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（4）函数与const"><a href="#（4）函数与const" class="headerlink" title="（4）函数与const"></a>（4）函数与const</h4><ol><li><p>const修饰函数的参数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> var<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//传递过来是形参，函数内的改变不会影响实际的值</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>var<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//参数指针所指内容为常量，不可变</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> var<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//参数指针本身为常量，不可指向其他对象</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>var<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//引用参数在函数内为常量不可变</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>const修饰函数的返回值</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//无意义，参数返回本身就是赋值</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//指针指向函数，指针内容不可变</span><span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//指针指向函数，指针本身不可变</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="（5）类与const"><a href="#（5）类与const" class="headerlink" title="（5）类与const"></a>（5）类与const</h4></li><li><p>const修饰成员变量，表示成员为常量，只能在初始化的时候赋值，不能被修改</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span> <span class="token keyword">const</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">age</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>const修饰成员函数，表示该函数不改变对象的成员变量，也不调用任何非const成员函数</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>const修饰类的对象，该对象只能调用类内const成员函数，另外类内任何成员都不能改变</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"non-const"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"const"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>int main(int argc, char *argv[]){<br>    const A a1;<br>    a1.test();                     //只能调用const成员函数<br>    return 0;<br>}</p><pre><code>##  二、Static关键字#### （1）面向对象的静态成员变量在类内成员变量的声明前加上关键字static，该数据成员就是类内的静态数据成员。**静态成员变量的特点**：- 静态成员变量是该类所有对象共享的，静态成员变量定义在全局(静态)存储区，不属于特定的类的对象，也不占对象的内存- 在类的对象没有生成前，静态成员变量就已经存在，可以通过`类名::对象名`访问- 静态成员变量存储在全局(静态)存储区，static成员变量的内存是在初始化的时候分配的，因此静态成员变量必须初始化，而且只能在类体外进行- 静态成员变量的访问方式：（1）类名::静态数据成员名（2）类对象名.静态数据成员名- 静态数据成员和普通数据成员一样遵从public、protected、private访问规则- sizeof运算符不会计算静态成员变量**静态成员变量的作用：**- 把所有对象共享的成员分配在全局(静态)存储区，节省了存储空间- 一变多变，只需要改变以此，就能改变所有对象的相应的值**静态成员变量和全局变量：**- 静态成员变量没有进入程序的全局命名空间，因此不存在与程序中其它全局命名冲突的可能- 可以实现信息隐藏。静态成员变量可以是private成员，而全局变量不能```cppclass A{    static int num;          // 声明静态数据成员}int A::num = 0;                 //必须在类外定义并初始化</code></pre><h4 id="（2）面向对象的静态成员函数"><a href="#（2）面向对象的静态成员函数" class="headerlink" title="（2）面向对象的静态成员函数"></a>（2）面向对象的静态成员函数</h4><p>在类内成员函数声明前加static，该成员函数就是静态成员函数<br><strong>静态成员函数的特点：</strong></p><ul><li>静态成员函数属于类本身，属于类定义的一部分，不具体作用于类的某个特定对象，在类的对象实例化前已存在，可以通过类名访问</li><li>普通成员函数隐含一个this指针，指向类的对象本身。而静态成员函数不作用于具体对象，因此不存在this指针</li><li>声明在类内，定义并初始化在类外，且类外定义时不加static</li><li>静态成员函数可以访问静态成员函数、静态成员变量，不能访问非静态成员函数、非静态成员变量；非静态成员函数可以任意访问</li><li>调用静态成员函数方法：（1）对象名.静态成员函数名（参数表）；对象名-&gt;静态成员函数名（参数表）（2）类名::静态成员函数名（参数表）<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">student</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> score<span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//声明静态成员函数</span><span class="token punctuation">}</span><span class="token keyword">int</span> student<span class="token operator">::</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> student<span class="token operator">::</span>score <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">int</span> student<span class="token operator">::</span><span class="token function">ave</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> score<span class="token operator">/</span>num<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//定义静态成员函数，只能在类外定义</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（3）面向过程的静态全局变量"><a href="#（3）面向过程的静态全局变量" class="headerlink" title="（3）面向过程的静态全局变量"></a>（3）面向过程的静态全局变量</h4></li></ul><p>在全局变量前，加上static，该变量就被定义为一个静态全局变量，其作用为：</p><ul><li>静态全局变量不能被其他文件所使用</li><li>其他文件中可以定义相同名字的变量，不会发生冲突<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//定义静态全局变量</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  n<span class="token operator">++</span><span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>n <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（4）面向过程的静态局部变量"><a href="#（4）面向过程的静态局部变量" class="headerlink" title="（4）面向过程的静态局部变量"></a>（4）面向过程的静态局部变量</h4></li></ul><p>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量<br><strong>局部变量和静态局部变量：</strong></p><ul><li>局部变量：在函数运行时，对于函数体内定义的局部变量，每当运行到该语句时，系统都会给该局部变量分配栈内存，但随着程序退出，系统会收回栈内存，对应的局部变量也就失效</li><li>静态局部变量：静态局部变量保存在全局(静态)存储区，而不是保存在栈内，每次的值都可以保存到下一次调用</li></ul><p><strong>静态局部变量的特点：</strong></p><ul><li>静态局部变量在全局数据区分配内存</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化</li><li>静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0</li><li>静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">static</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>cout<span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>n<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//10</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//11</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//12</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（5）面向过程的静态函数"><a href="#（5）面向过程的静态函数" class="headerlink" title="（5）面向过程的静态函数"></a>（5）面向过程的静态函数</h4></li></ul><p>在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//定义静态函数</span>  <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、Extern关键字"><a href="#三、Extern关键字" class="headerlink" title="三、Extern关键字"></a>三、Extern关键字</h2><p>作用1：<code>extern “C”{}</code>：告诉编译器这部分代码是由C语言写的，不是C++<br>作用2：用extern关键字声明的全局变量和函数可以被跨文件访问</p><h2 id="四、Explicit关键字"><a href="#四、Explicit关键字" class="headerlink" title="四、Explicit关键字"></a>四、Explicit关键字</h2><p>在C++，将<code>explicit</code>关键字用来修饰类的构造函数，表示该类不能发生隐式类型转换，只能以显示的方式进行类型转换</p><ul><li><code>explicit</code>关键字只能用于类内部的构造函数上</li><li><code>explicit</code>关键字作用于单个参数的构造函数<pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span>A a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>int main(){<br>    //show()接收一个A类的对象，此处传入一个int型参数<br>    //程序能成功运行，因为此处发生了隐式转换<br>    show(1);<br>}</p><pre><code>## 五、Override关键字父类中使用了虚函数，子类需要对这个虚函数进行重写时：```cppclass A{    virtual void foo();}class B : public A{    //方法1    void foo();    //方法2    virtual void fuoo();    //方法3    void foo() override;}</code></pre><p>以上三种重写方法都是可行的，但是如果错写<code>void f00()</code>时，编译时前两种方法是不会报错的，编译器认为这是新的函数，但是写了override关键字后，编译就会报错</p><h2 id="六、Final关键字"><a href="#六、Final关键字" class="headerlink" title="六、Final关键字"></a>六、Final关键字</h2><p>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>final<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//foo()在其子类中不可被重写</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">B</span> final<span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//类B不能被继承</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Overlapping Community Detection Based on Random Walk and Seeds Extension</title>
      <link href="/2020/09/12/overlapping-community-detection-based-on-random-walk-and-seeds-extension/"/>
      <url>/2020/09/12/overlapping-community-detection-based-on-random-walk-and-seeds-extension/</url>
      
        <content type="html"><![CDATA[<h1 id="Overlapping-Community-Detection-Based-on-Random-Walk-and-Seeds-Extension"><a href="#Overlapping-Community-Detection-Based-on-Random-Walk-and-Seeds-Extension" class="headerlink" title="Overlapping Community Detection Based on Random Walk and Seeds Extension"></a>Overlapping Community Detection Based on Random Walk and Seeds Extension</h1><h2 id="种子拓展的局部社区发现算法"><a href="#种子拓展的局部社区发现算法" class="headerlink" title="种子拓展的局部社区发现算法"></a>种子拓展的局部社区发现算法</h2><p>&emsp;&emsp;全局的社区发现方法有：层次聚类算法，谱方法，基于团的方法，边聚类，标签传播等。</p><p>&emsp;&emsp;全局的社区发现需要对整个网络结构信息进行整体认知，在规模不大或者不完整的复杂网络中就会存在一些缺陷，所以就有人提出了基于种子拓展的局部社区发现方法。</p><p>&emsp;&emsp;基于种子拓展的局部社区发现算法通常是从网络的种子节点出发，利用社区的局部信息不断的从网络中加入节点来发现社区结构。</p><h2 id="SEOCD"><a href="#SEOCD" class="headerlink" title="SEOCD"></a>SEOCD</h2><p>&emsp;&emsp;为了能够准确的发现网络中的重叠社区结构，本文提出了基于随机游走和种子拓展的重叠社区发现算法（SEOCD）。在种子选取阶段，采用随机游走 $t$ 步之后最有可能返回自身的节点作为种子，根据节点和社区的相似度找出种子邻居集中相似度大于设定阈值的节点，与种子节点一起构成紧密的种子社区。</p><h4 id="1-概念介绍"><a href="#1-概念介绍" class="headerlink" title="1. 概念介绍"></a>1. 概念介绍</h4><p>&emsp;&emsp;$G(V,E)$表示图或者网络，$V$为点集，$E$为边集，$n=|V|$表示节点数，$m=|E|$表示边数。</p><p><strong>定义1：</strong>转移概率矩阵$p_{uv}$<br>$$<br>p_{uv}=A_{uv}/k_v<br>\tag{1}<br>$$<br>&emsp;&emsp;式中，$A_{uv}$为邻接矩阵，$k_v$为节点$v$的度。$p_{uv}$表示节点$u$随机游走一步到达节点$v$的概率，随机游走$t$步后的转移概率矩阵为$p_{uv}^t$。</p><p><strong>定义2</strong>：评分矩阵B：<br>$$<br>B=\sum_{t=1}^Tp_{uv}^t<br>\tag{2}<br>$$<br>&emsp;&emsp;评分矩阵$B$中每个元素代表节点$u$走$t$步后到达节点$v$所得到的评分，用$B(u,v)$表示，若两个节点连接越紧密，其评分越高。</p><p><strong>定义3：</strong>社区邻居集$NBSet(C_i)$表示与社区$C_i$有连接边的节点集合：<br>$$<br>NBSet(C_i)=\bigcup_{v\in C_i}\Gamma(v)<br>\tag{3}<br>$$</p><p>$$<br>\Gamma(v)=\{u:u\in V,(v,u)\in E\}<br>\tag{4}<br>$$</p><p>&emsp;&emsp;式中，$C_i$表示一个社区，$\Gamma(v)$表示节点$v$的邻域集合。</p><p><strong>定义4：</strong>节点$v$与社区$C_i$相似度$NC_SIM(v,C_i)$：<br>$$<br>NC_SIM(v,C_i)=\frac{k_v^{C_i}}{k_v}<br>\tag{5}<br>$$<br>&emsp;&emsp;式中，$k_v^{C_i}$表示节点$v$与社区$C_i$关联边的度，$k_v$为节点$v$的度，$NC_SIM(v,C_i)$越大，节点$v$越有可能属于社区$C_i$。</p><p><strong>定义5：</strong>社区$C_i$和社区$C_j$的相似度$CC_SIM(C_i,C_j)$定义为：<br>$$<br>CC_SIM(C_i,C_j)=\frac{|overlap(C_i,C_j|}{min(|C_i|,|C_j|)}<br>\tag{6}<br>$$<br>&emsp;&emsp;式中，$|overlaop(C_i,C_j)|$表示社区$C_i$和$C_j$共有的节点数，$|C_i|$表示社区$C_i$的节点数。$CC_SIM(C_i,C_j)$越大，表示两个社区结构越相近，当超过一个阈值$\varepsilon$时，则需合并两个社区。</p><p><strong>定义6：</strong>自适应函数用于衡量一组节点的紧密程度，具体公式定义如下：<br>$$<br>f_{\rm g}=\frac{k_{in}^{\rm g}}{(k_{in}^{\rm g}+k_{out}^{\rm g})^{\alpha}}<br>\tag{7}<br>$$<br>&emsp;&emsp;式中：$k_{in}^{\rm g}$和$k_{out}^{\rm g}$为子图$\rm g$内部度和外部度的总值，参数$\alpha$是一个正实数，用于控制发现的社区的规模。</p><h4 id="2-SEOCD算法的实现"><a href="#2-SEOCD算法的实现" class="headerlink" title="2. SEOCD算法的实现"></a>2. SEOCD算法的实现</h4><p>&emsp;&emsp;基于随机游走与种子拓展重叠社区发现算法（Seeds Extension Overlapping Community Detection，SEOCD）核心步骤为检测种子社区和社区拓展挖掘。在种子社区检测阶段，采用随机游走的策略找到初始种子，然后选择与种子紧密相连的邻居节点一起构成种子社区；在社区拓展阶段，利用局部节点和邻居节点相关信息，取具有最大相似度且能够优化局部自适应函数的节点来加入社区，以实现整个网络的社区划分。由于每个种子社区都是沿其邻居集独立进行社区拓展，因此可以发现重叠社区。</p><p>&emsp;&emsp;SEOCD算法分为4个阶段：（1）种子社区检测（2）相似种子社区合并（3）社区拓展挖掘（4）社区优化</p><p><strong>（1）种子社区检测</strong></p><p>&emsp;&emsp;首先计算每个节点$v$随机游走$t$步后回到自身的评分值$B(u,v)$，按评分值排序，选择最高的$l$个节点作为初始种子，然后按公式（5）找出初始种子社区邻居集中与种子社区相似度$NC_SIM$大于阈值$\varepsilon$的节点，与$v$合并得到社区$S$。</p><p><strong>（2）相似种子社区合并</strong></p><p>&emsp;&emsp;在检测种子社区阶段，由于是基于整个网络选取的种子构成种子社区，可能会出现两个种子社区的相似度高的情况，因此需要将其合并。根据公式（6）计算社区之间相似度$CC_SIM(C_i,C_j)$，如果相似度大于阈值$\varepsilon$，则合并两个种子社区。</p><p><strong>（3）社区拓展挖掘</strong></p><p>&emsp;&emsp;得到稳定紧密的种子社区后，从种子社区出发进行社区拓展挖掘：首先遍历种子社区的邻居集$NBSet$，根据公式（5）计算每个邻居节点和社区的相似度，取前面$l$个最高相似度的种子，然后计算这些节点加入局部社区后的自适应函数值，把能够让自适应函数值增加的节点加入到社区，否则就将其设置为自由节点，同时删除社区中让自适应函数值减少的节点。最后更新$NBSet$并重复上述步骤，知道$NBSet$为空。</p><p><strong>（4）社区优化</strong></p><p>&emsp;&emsp;在社区拓展过程中，可能还会存在不属于任何社区的自由节点，而且社区集合中还会出现相似度高的社区。因此需要对社区进行优化。首先，计算节点和社区的相似度，把自由节点分到相似度最高的社区；然后，根据公式（6）计算社区与社区之间的相似度，合并相似度高的社区；最后输出网络社区划分的结果</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Community Detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Community Detection Using Restrained Random-walk Similarity</title>
      <link href="/2020/09/11/community-detection-using-restrained-random-walk-similarity/"/>
      <url>/2020/09/11/community-detection-using-restrained-random-walk-similarity/</url>
      
        <content type="html"><![CDATA[<h1 id="Community-Detection-Using-Restrained-Random-walk-Similarity"><a href="#Community-Detection-Using-Restrained-Random-walk-Similarity" class="headerlink" title="Community Detection Using Restrained Random-walk Similarity"></a>Community Detection Using Restrained Random-walk Similarity</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>&emsp;&emsp;从一个节点开始长度有限的随机游走，如果这个节点经过了与之相似的节点集合，则认为这个节点也属于这个节点集合（即社区）。这个方法的提出是基于下列的思想：从初始节点出发进行游走，游走到和这个节点同属于一个社区的节点集合，那么初始节点和这个节点集合一定是相似的，因为初始节点最初更倾向于在该社区内进行游走。</p><p>在以下两条件下，此方法效果更强：</p><p><strong>1. 多次游走，删除不常访问节点</strong></p><p>&emsp;&emsp;首先是避免异常的随机游走，因为游走有较小概率离开初始节点所在的社区，导致错误的聚类。异常随机游走的起始顶点被错误地聚类。<strong>因此，从每个节点出发，进行多次随机游走，将很少游走到的节点从可能游走经过的节点集合中删除。多次实验，就能减少小概率事件发生带来的偏差。</strong></p><p><strong>2. 适时停止随机游走</strong></p><p>&emsp;&emsp;在适当时间强制终止随机游走，根据观察：在第1阶段，随机游走会经常访问没有访问过的节点；在第2阶段，随机游走会重复访问已经访问过得节点，此时仍在初始节点所在的社区中游走；在第3阶段，随机游走会从最初的社区游走到其他社区。在理想情况下，应该在第二阶段停止随机游走。</p><p>&emsp;&emsp;第二个条件对于规模大，规模小的社区发现都很有效。为了发现规模较大的社区，随机游走的长度需要更大；为了发现规模较小的社区，随机游走的长度需要短一些。总之，需要确定合适的随机游走长度阻止游走离开最初的社区。即定义一个阈值，自适应决定游走的步长。</p><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>（1）Traditional Graph Partitioning（2）Modularity Optimization（3）Potts Mode（4）Random Walk（5）Statistical inference （6）Other Techniques</p><h2 id="3-Restrained-Random-Walk-Similarity-Method"><a href="#3-Restrained-Random-Walk-Similarity-Method" class="headerlink" title="3. Restrained Random-Walk Similarity Method"></a>3. Restrained Random-Walk Similarity Method</h2><h3 id="3-1-Random-Walk-Similarity-Method"><a href="#3-1-Random-Walk-Similarity-Method" class="headerlink" title="3.1 Random-Walk Similarity Method"></a>3.1 Random-Walk Similarity Method</h3><p>&emsp;&emsp;Random-Walk Similarity Method是Restrained Random-Walk Similarity Method的基础，用下图简单介绍一下Random-Walk Similarity Method：</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/随机游走相似性.png" alt="随机游走相似性" style="zoom:50%;"><p>&emsp;&emsp;从社区1中的节点开始随机游走，一段时间内，游走更倾向在社区1内游走，因为从社区1到社区2的边很少，游走出去的概率就小。同样地，从社区2开始的随机游走也是更倾向于在社区2内游走。基于随机游走的这种特性，如果在从所有节点执行有限长度的随机游走之后，游走经过的节点集之间存在高度相似性，因此本文的方法会将随机游走的起始节点和这些经过的节点聚集到相同的社区中。</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/Random Walk Similarity Method.png" alt="Random Walk Similarity Method" style="zoom:50%;"><p>&emsp;&emsp;详细步骤如Algorithm 1所示：在3-12行，每个节点$（v_1,…v_N）$都进行长度为$m$的随机游走，并获得随机游走序列$S_1,…S_N$。理想情况下，$S_i$应该只包括初始节点$v_i$和同个社区内的节点。然而，随机游走可能会从初始节点所在社区游走到其他社区，甚至可能在刚开始游走不久就离开了初始社区，因此集合$S_i$会包括了$v_i$以及和$v_i$不属于同个社区的节点。为了避免这种情况，在4-7行中，每个节点重复$p$次随机游走，并且只有频繁访问的节点才会被添加到$S_i$中（第8-11行）。在13-15行，节点$v_1,…v_N$基于集合$S_1,…,S_N$之间的Jaccard相似系数进行聚类。如果$sim(S_i,S_j)\geq th_{sim}$，节点$v_i$和$v_j$则归为同一类。还有一种特殊情况，也把$v_i$和$v_j$归为一类，没看懂，不谈。</p><h3 id="3-2-Restraning-a-Random-Walk"><a href="#3-2-Restraning-a-Random-Walk" class="headerlink" title="3.2 Restraning a Random Walk"></a>3.2 Restraning a Random Walk</h3><p>&emsp;&emsp;在Random Walk Similarity中，很难去决定随机游走的长度（m），尤其是当图中有规模大的社区和规模小的社区的时候。然而，当m偏小时，尽管$v_i$和$v_j$处于同一个大规模社区中，$sim(S_i,S_j)$会偏小，因此大规模社区会被识别成多个小规模社区；而当m偏大时，从小社区中初始节点开始的随机游走会游走到其他社区中，因此$sim(S_i,S_j)$会偏高，小规模社区中的初始节点会被错误归类到其他社区中，导致无法识别小规模社区。</p><p>&emsp;&emsp;为了解决这个问题，当随机游走已经经过了很多初始社区中的节点，且随机游走还没游走到另一个社区时，重新进行随机游走。</p><p>&emsp;&emsp;首先考虑随机游走的步长和游走经过的唯一节点数之间的关系。下图表示Japanese temple/shrine数据集中具有17个节点的社区，从该社区中某点开始随机游走的过程：</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/随机游走.png" alt="随机游走" style="zoom:50%;"><p>&emsp;&emsp;第一阶段，随机游走会大概率游走到未访问过的节点；第二阶段，随机游走会经常游走到已经访问过得节点；第三阶段，随机游走到新的社区，会访问未访问过的节点。</p><p>&emsp;&emsp;基于上述观察，随机游走应该在第二阶段终止。当给定步长$w$下，随机游走访问的unique节点的增长$(n_i-n_{i-(w-1)})$小于算法中给定阈值，即停止随机游走，具体算法如下所示：</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/Restrained random walk.png" alt="Restrained random walk" style="zoom:50%;"><p>&emsp;&emsp;思路和Random-Walk Similarity Method差不多，只是加了游走停止的规则。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Community Detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adaptive Graph Encoder for Attributed Graph Embedding</title>
      <link href="/2020/09/05/adaptive-graph-encoder-for-attributed-graph-embedding/"/>
      <url>/2020/09/05/adaptive-graph-encoder-for-attributed-graph-embedding/</url>
      
        <content type="html"><![CDATA[<h1 id="Adaptive-Graph-Encoder-for-Attributed-Graph-Embedding"><a href="#Adaptive-Graph-Encoder-for-Attributed-Graph-Embedding" class="headerlink" title="Adaptive Graph Encoder for Attributed Graph Embedding"></a>Adaptive Graph Encoder for Attributed Graph Embedding</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>​        属性图嵌入是图分析中具有挑战性的一项任务。目前GCN已经取得了引人注目的成果，但是GCN存在着以下缺点：（1）实验表明，图卷积滤波器（即图卷积核）和权重矩阵的纠缠会损害性能和鲁棒性（2）我们证明了这些方法中的图卷积滤波器是广义拉普拉斯平滑滤波器的特例，但他们并没有保留最佳的低通特征（3）现有算法的训练目标通常是恢复与现实应用并不总是一致的邻接矩阵或特征矩阵。</p><p>​        为了解决这些问题，我们提出了AGE（Adaptive Graph Encoder），AGE由两部分组成：（1）为了更好地减轻节点特征中的高频噪声，AGE应用了特殊的拉普拉斯平滑滤波器（2）AGE采用了自编码器，可以迭代地增强滤波后的特征，以实现更好的节点嵌入。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>​        属性图应用广泛，为了对属性图进行分析，研究人员已经提出了多种基于机器学习的方法，来进行诸如节点分类，链接预测等属性图分析任务。但是由于高维，非欧式的图结构特征和丰富的节点属性特征，属性图嵌入仍面临着巨大挑战。</p><p>​        网络表示学习旨在将高维的图结构编码为低维的实值的向量形式，早期的图嵌入方法基于拉普拉斯特征图，矩阵分解，随机游走。但是这些方法属于浅结构，受到诸多限制。</p><p>​        最近，图上的深度学习非常流行，并且GCN及其变体在图学习任务上取得了非常好的表现，如属性图嵌入任务。在这些方法大多基于GAE（Graph Autoencoder）和VGAE（Variational Graph Autoencoder），如下图所示。但是这些基于GCN的方法有三个主要缺点：</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/图1：图自编码器.png" alt="图1：图自编码器" style="zoom:50%;"><ul><li><p>GCN编码器有多个图卷积层，每层包含了一个图卷积核（图1中的H），一个权重矩阵（图1中的$W_1$和$W_2$）以及一个激活函数。然而，先前的工作表明，卷积核和权重矩阵的纠缠无法为半监督图表示学习提供性能增益，甚至会损害训练效率，因为它加深了反向传播的路径。本文中，我们通过受控实验将这一结论进一步拓展到无监督的场景中，表明本文的解纠缠体系结构比纠缠模型具有更好，更强大的功能。</p></li><li><p>先前的工作证明了图卷积滤波器即为在特征矩阵上应用拉普拉斯平滑滤波器进行低通噪声处理。但是我们证明，现有的图卷积滤波器不是最佳的低通滤波器，因为它们不能滤除某些高频间隔中的噪声，因此，它们无法到达最佳平滑效果。</p></li><li><p>我们认为，这些算法的训练目标（重建邻接矩阵或特征矩阵）与现实的应用不兼容。重建邻接矩阵，即尽力与真实链接信息拟合，然而在缺乏特征信息的情况下，并不合适；重建特征矩阵，会强使模型记住特征中的高频特征，因此也不适合。</p><p>​    基于以上原因，我们提出了AGE框架。</p></li></ul><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><h3 id="2-1-Conventional-Graph-Embedding"><a href="#2-1-Conventional-Graph-Embedding" class="headerlink" title="2.1 Conventional Graph Embedding"></a>2.1 Conventional Graph Embedding</h3><p>​        常规图嵌入：（1）基于拉普拉斯特征矩阵（2）基于矩阵分解（3）基于随机游走</p><h3 id="2-2-GCN-based-Graph-Embedding"><a href="#2-2-GCN-based-Graph-Embedding" class="headerlink" title="2.2 GCN-based Graph Embedding"></a>2.2 GCN-based Graph Embedding</h3><p>​        由于GCN的强大表示学习能力，基于GCN的属性图嵌入方法目前是性能最佳的。对于缺少标签信息的无监督图嵌入，可以将基于GCN的优化目标分为两类：</p><p><strong>1. Reconstruct the adjacency matrix</strong></p><p>​        这类方法主要通过学习嵌入向量来恢复局部邻域结构。GAE和VGAE将GCn作为编码器来进行嵌入学习，然后通过交叉熵损失对内积进行解码。</p><p><strong>2. Reconstruct the feature matrix</strong></p><p>​        这种模型是节点特征矩阵的自编码器，而邻接矩阵仅充当过滤器。</p><h2 id="3-Proposed-Method"><a href="#3-Proposed-Method" class="headerlink" title="3. Proposed Method"></a>3. Proposed Method</h2><h3 id="3-1-Problem-Formalization"><a href="#3-1-Problem-Formalization" class="headerlink" title="3.1 Problem Formalization"></a>3.1 Problem Formalization</h3><p>​        给定一属性图${\cal G=(V,E},X)$，其中${\cal V}=\{v_1,v_2,…,v_n\}$是点集，$\cal E$是边集，$X=[x_1,x_2,…,x_n]^T$是特征矩阵。图$\cal G$的拓扑结构可以用邻接矩阵$A={a_{ij}}\in{\Bbb R}^{n\times n}$表示，其中如果$v_i$和$v_j$相连，则$a_{ij}=1$。$D=diag(d_1,d_2,…,d_n)\in {\Bbb R}^n\times n$表示邻接矩阵$A$的度矩阵，$d_i=\sum_{v_i\in{\cal V}}a_{ij}$为节点$v_i$的度矩阵。拉普拉斯矩阵定义为$L=D-A$。</p><p>​        属性图嵌入的目的即将节点映射为低维向量，我们定义$Z$为嵌入矩阵，嵌入向量应该保留图$\cal G$中的拓扑结构信息和属性特征信息。</p><p>​        我们将节点聚类和链接预测作为下游任务。节点聚类任务旨在节点划分为不相交的组${G_1,G_2,…,G_m}$，其中相似的节点属于同一组。链接预测任务即预测两个节点之间是否存在边。</p><h3 id="3-2-Overall-Framework"><a href="#3-2-Overall-Framework" class="headerlink" title="3.2 Overall Framework"></a>3.2 Overall Framework</h3><p>​        本文模型由两部分组成：</p><ul><li><strong>Laplacian Smoothing Filter：</strong>设计的滤波器$H$用作低通滤波器，以对特征矩阵$X$的高频分量进行消噪。平滑后的特征矩阵$\tilde X$被用作自适应编码器的输入。</li><li><strong>Adaptive Encoder:</strong>为了获得更有表达能力的节点嵌入，该模块通过自适应选择高度相似或不相似的节点对来构建训练集，然后以监督的方式训练编码器。</li></ul><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/AGE框架.png" alt="AGE框架" style="zoom: 50%;"><h3 id="3-3-Laplacian-Smoothing-Filter"><a href="#3-3-Laplacian-Smoothing-Filter" class="headerlink" title="3.3 Laplacian Smoothing Filter"></a>3.3 Laplacian Smoothing Filter</h3><p>​        图学习的基本假设是：图上附近节点应该是相似的，因此节点特征在图流形上应该是平滑的。</p><p><strong>1. Analysis of Smooth Signals：</strong></p><p>​        我们首先从图形信号处理的角度解释平滑，把$x\in {\Bbb R}^T$作为图形信号，其中为每个节点分配了一个标量，定义过滤器矩阵为$H$。为了测量图信号$x$的平滑性，我们可以计算Rayleigh Quotient：<br>$$<br>R(L,x)=\frac{x^{\sf T}Lx}{x^{\sf T}x}=\frac{\sum_{(i,j)\in{\cal E}}(x_i-x_j)^2}{\sum_{i\in {\cal V}}x_i^2}<br>\tag{1}<br>$$<br>​        这个商实际上是$x$的归一化方差得分。如上所述，平滑信号应该在相邻节点上分配相似的值，因此，假定具有较低Rayleigh Quotient的信号更平滑。</p><p>​        拉普拉斯算子的特征分解$L=U\Lambda U^{-1}$，其中$U\in {\Bbb R}^{n\times n}$包含了特征向量，$\Lambda=diag(\lambda_1,\lambda_2,….,\lambda_n)$是特征值的对角矩阵，本证向量$u_i$的平滑度如下定义：<br>$$<br>R(L,u_i)=\frac{u_i^{\sf T}Lu_i}{u_i^{\sf T}u_i}=\lambda_i<br>\tag{2}<br>$$<br>​        公式（2）表示更平滑的特征向量与更小的特征值相关，更小的特征值意味着评率更低。因此，我们基于基于公式（1）（2）分解信号$x$：<br>$$<br>x=Up=\sum_{i=1}^np_iu_i<br>\tag{3}<br>$$<br>式中：$p_i$是$u_i$的特征向量系数，信号$x$的平滑度实际为：<br>$$<br>R(L,x)=\frac{x^{\sf T}Lx}{x^{\sf T}x}=\frac{\sum_{i=1}^np_i^2\lambda_i}{\sum_{i=1}^np_i^2}<br>\tag{4}<br>$$<br>因此，为了获得更平滑的信号，<strong>设计滤波器的目标为：滤除高频分量的同时保留低频分量</strong>。由于其高计算效率和令人信服的性能，拉普拉斯平滑滤波器通常用于此目的。</p><p><strong>2. Generalized Laplacian Smoothing Filter：</strong></p><p>​        广义拉普拉斯平滑滤波器定义如下：<br>$$<br>H=I-kL<br>\tag{5}<br>$$<br>式中：$k$为实值。用$H$作为滤波器矩阵，滤波信号$x$如下所示：<br>$$<br>\tilde x=Hx=U(I-k\Lambda)U^{-1}Up=\sum_{i=1}^n(1-k\lambda_i)p_iu_i=\sum_{i=1}^np_i’u_i<br>\tag{6}<br>$$<br>因此，为了实现低通滤波，频率响应函数$1-k\lambda$应该是一个减量和非负函数。堆叠$t$个拉普拉斯平滑滤波器，我们将滤波后的特征矩阵$X$表示为：<br>$$<br>\tilde X=H^tX<br>\tag{7}<br>$$<br>注意，过滤器完全是非参数的。</p><p><strong>3. The Choice of $k$.：</strong></p><p>​        $\tilde A=I=A$，我们使用对称归一化图拉普拉斯算子：<br>$$<br>\tilde L_{sym}=\tilde D^{-\frac{1}{2}}\tilde L\tilde D^{-\frac{1}{2}}<br>\tag{8}<br>$$<br>式中：$\tilde D$和$\tilde L$是$\tilde A$的度矩阵和拉普拉斯矩阵。然后滤波器可以如下定义：<br>$$<br>H=I-k\tilde L_{sym}<br>\tag{9}<br>$$<br>注意：如果我们设置$k=1$，滤波器就成了GCN滤波器。</p><p>​        为了选择最佳的$k$，特征值$\tilde \Lambda$的分布（分解$\tilde L_{sym}=\tilde U\tilde \Lambda\tilde U^{-1}$得到)应该被仔细分析，$\tilde x$的平滑度为：<br>$$<br>R(L,\tilde x)=\frac{\tilde x^{\sf T}L\tilde x}{\tilde x^{\sf T}\tilde x}=\frac{\sum_{i=1}^np_i’^2\lambda_i}{\sum_{i=1}^np_i’^2}<br>\tag{10}<br>$$<br>因此，$p_i’^2$应该随着$\lambda_i$的增加而减少。定义最大的特征值为$\lambda_{max}$，理论上，如果$k&gt;\frac{1}{\lambda_{max}}$，滤波器在$(1/k,\lambda_{max}]$区间内无法通过，因为$p_i’^2$在此区间内增大。此外，如果$k&lt;\frac{1}{\lambda_{max}}$，滤波器无法过滤所有高频成分。所以，$k=\frac{1}{\lambda_{max}}$是最佳选择。</p><p>​        已经有研究人员证明：拉普拉斯特征值的范围在0到2之间，因此，GCN滤波器在$(1,2]$区间内不是低通的。我们的实验证明：在重新规范化后，最大的特征值$\lambda_{max}$会缩小到3/2左右，这时，1/2已不是最佳选择。在本文的实验中，我们计算每个数据集的$\lambda_{max}$，然后设置$k=\frac{1}{\lambda_{max}}$。我们也进一步分析了不同的$k$的影响。</p><h3 id="3-4-Adaptive-Encoder"><a href="#3-4-Adaptive-Encoder" class="headerlink" title="3.4 Adaptive Encoder"></a>3.4 Adaptive Encoder</h3><p>​        经过$t$层的拉普拉斯平滑的过滤后，输出的特征更加平滑，同时也保留了丰富的属性信息。</p><p>​        为了学习更好的节点嵌入,我们需要找到合适的无监督优化目标。最后，受到深度自适应学习（Deep Adaptive Learning）的启发，我们利用了成对节点相似性。对于属性图嵌入任务，两个节点之间的关系至关重要，这要求训练目标必须是合适的相似度度量。基于GAE的方法通常选择邻接矩阵作为节点对的真实标签。但是我们认为邻接矩阵只能记录1-hop的结构信息，这是不够的。同时，我们认为，由于平滑特征或经过训练的嵌入的相似性更加准确，因为它们将结构和特征融合在了一起。最后，我们自适应地选择相似度高的节点对作为正样本，而相似度低的节点对作为负样本。</p><p>​        给定过滤后的特征矩阵$\tilde X$，节点嵌入由线性编码器$f$编码：<br>$$<br>Z=f(\tilde X;W)=\tilde XW<br>\tag{11}<br>$$<br>式中：$W$是权重矩阵。然后使用min-max所放弃将嵌入缩放到$[0,1]$区间，以减少方差。为了测量节点的成对相似性，我们利用余弦函数来实现我们的相似性度量。相似度矩阵$S$定义如下：<br>$$<br>S=\frac{ZZ^{\sf T}}{||Z||_2^2}<br>\tag{12}<br>$$<br><strong>1. Training Sample Selection：</strong></p><p>​        在计算相似度矩阵后，我们将成对相似性序列进行降序排列。$r_{ij}$为节点对$(v_i,v_j)$的排序。定义正样本的最高排序为$r_{pos}$，负样本的最低排序为$r_{neg}$，因此生成节点对$(v_i,v_j)$标签为：<br>$$<br>l_{ij}=\left\{<br>\begin{aligned}<br>&amp;1  \qquad \qquad r_{ij}\leq r_{pos}    \<br>&amp;0  \qquad \qquad r_{ij}&gt; r_{pos}    \<br>&amp;None \qquad  otherwise<br>\end{aligned}<br>\right.<br>\tag{13}<br>$$<br>​        通过这种方法，$r_{pos}$个正样本，$n^2-r_{neg}$个负样本的训练集就构建成了。特别地，由于编码器没有经过训练，在第一次构造训练集的时候，我们直接将平滑后的特征用于初始化$S$：<br>$$<br>S=\frac{\tilde X\tilde X^{\sf T}}{||\tilde X||_2^2}<br>\tag{14}<br>$$<br>​        构件训练集后，我们可以在有监督的方式下训练编码器。在现实世界的图中，不相似的节点对总是比相似的节点对多得多，因此我们在训练集中选择的负样本数要多于$r_{pos}$。为了平衡正样本和负样本，我们在每个epoch中随机选择$r_{pos}$个负样本。平衡后的样本集合定义为$O$。最后，交叉熵损失函数定义如下：<br>$$<br>{\cal L}=\sum_{(v_i,v_j)\in O}-l_{ij}log(s_{ij})-(1-l_{ij})log(1-s_{ij})<br>\tag{15}<br>$$<br><strong>2. Thresholds Update：</strong></p><p>​        受到curriculum learning的启发，我们设计了一种特别的$r_{pos}$和$r_{neg}$更新策略，以控制训练集的规模。在训练过程开始时，会为编码器选择更多样本以找到粗糙的聚类模式。之后，仍保留较高置信度的样本用于训练，迫使编码器捕获精炼的模式。在实践中，随着训练过程的进行，$r_{pos}$减少，$r_{neg}$增加。我们设置初始阈值为$r_{pos}^{st},r_{neg}^{st}$，设置最终阈值为$r_{pos}^{ed},r_{neg}^{ed}$，使$r_{pos}^{ed}\leq r_{pos}^{st},r_{neg}^{ed}\geq r_{neg}^{st}$。假设阈值更新$T$次，更新策略可表示为：<br>$$<br>r’_{pos}=r_{pos}+\frac{r_{pos}^{ed}-r_{pos}^{st}}{T}<br>\tag{16}<br>$$</p><p>$$<br>r’_{neg}=r_{neg}+\frac{r_{neg}^{ed}-r_{neg}^{st}}{T}<br>\tag{17}<br>$$</p><p>​        随着训练的进行，每次更新阈值时，我们都会重建训练集并保存嵌入。对于节点聚类任务，我们对保存的嵌入的相似矩阵进行Spetral Clustering，并在根据DBI选择最佳的epoch；对于链接预测任务，我们在验证集上选择效果最佳的epoch。</p><p>​        算法流程图如下所示：</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/算法流程图.png" alt="算法流程图" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Embedding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Community Detection in Attributed Graphs: An Embedding Approach</title>
      <link href="/2020/08/29/community-detection-in-attributed-graphs-an-embedding-approach/"/>
      <url>/2020/08/29/community-detection-in-attributed-graphs-an-embedding-approach/</url>
      
        <content type="html"><![CDATA[<h1 id="Community-Detection-in-Attributed-Graphs-An-Embedding-Approach"><a href="#Community-Detection-in-Attributed-Graphs-An-Embedding-Approach" class="headerlink" title="Community Detection in Attributed Graphs: An Embedding Approach"></a>Community Detection in Attributed Graphs: An Embedding Approach</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>​        社区发现是一个被广泛研究的基本问题，其旨在发现紧密连接的节点群。随着现实网络中可用于实体的丰富信息的激增，在属性图中发现具有属性的社区意义重大。然而，目前现有的属性社区发现方法直接使用了原始的网络拓扑结构，导致结果不理想。本文中，我们提出了一种新颖的属性社区发现方法，具体而言，基于对社区中紧密连接的结构的观察，我们开发了一种新颖的社区结构嵌入方法，以通过底层社区隶属度对固有的社区结构进行编码。基于节点属性和社区结构嵌入，我们将属性社区发现公式华为非负矩阵分解优化问题。此外，我们精心设计了迭代更新规则，以确保找到一个收敛的解决方法。在19个属性图数据集上进行了广泛的实验，这些数据集具有重叠的和非重叠的真实社区，这表明我们提出的模型CDE可以准确识别归因社区，并且明显优于7种最新方法。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>​        社区作为功能模块广泛而自然地存在于现实世界的网络中，例如社交网络，协作网络和Web网络。社区发现（图聚类）算法是分析和理解大型网络的基础分析工具。在文献中，提出了许多基于网络拓扑结构来发现社区的方法。除了网络拓扑结构外，网络中的节点通常具有属性信息，这对于理解社区意义很重要，例如：引文网络中的论文都有关键词。这种具有节点属性的网络称为属性图。</p><p>​        由于网络结构和节点属性这两种信息的不同，它给在属性图中发现有意义的社区带来了挑战。已经提出了很多中结合了拓扑结构信息和节点属性信息的方法。然而，对于无权重网络而言，所有这些方法都直接利用原始网络拓扑信息，该拓扑通过为每条边分配相同的值来忽略固有的社区结构。由于社区内的节点连接紧密，因此在属性图中存在大量紧密连接的子图。从直觉上讲，形成那些紧密连接的子图中的边比连接不同子图的边更容易构建相应的社区。考虑到图1中的例子，图（a）中，有两对相连的节点对$(v_1,v_3)$和$(v_1,v_2)$，其中$v_1$和$v_3$属于相同的社区，$v_1$和$v_2$则属于不同的社区，原始的拓扑结构不会反映这两对节点对之间的差异，因为这两对都分配了相同的值，1。然而$(v_1,v_3)$在构建社区中明显比$(v_1,v_2)$更重要。因此直接利用原始的拓扑结构会导致对节点对的一视同仁，而不管他们是否在同一个紧密连接的结构里。</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/邻接矩阵和社区结构嵌入矩阵对社区结构编码性能的比较.png" alt="邻接矩阵和社区结构嵌入矩阵对社区结构编码性能的比较" style="zoom:50%;"><p>​        节点在一个紧密相连的社区中，他们应该共享同质节点属性。作为最先进的方法之一，SCI将网络拓扑结构和节点属性与统一的目标函数结合在一起。然而，SCI不会分解稀疏的节点属性矩阵，而是将其作为适合社区隶属度的基础，由于节点属性矩阵的冗余和噪声，这会降低SCI的有效性。</p><p>​        本文中，我们研究了属性社区发现问题，旨在发现节点间紧密相连且具有同类属性的社区。社区是可以重叠的，即一个节点可以属于多个社区。为了解决直接使用原始网络拓扑结构并充分利用节点属性的问题，我们提出了一种新的介于社区结构嵌入的社区发现模型，该模型结合了社区结构和节点属性。具体而言，我们基于对社区中紧密相连的结构的观察，提出了一种新颖的社区结构嵌入方法，以通过底层社区隶属度对固有社区结构进行编码。然后利用节点属性信息和社区结构嵌入，将属性社区发现公式转化为非负矩阵特征优化问题，并精心设计更新规则，以确保找到收敛的解决方法。</p><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>​        本文相关工作包括了结构图聚类，属性图聚类，网络嵌入。图聚类（社区发现）算法被广泛研究，本文中，我们重点关注图生成模型，图生成模型算法假设边是根据基于社区隶属度定义的概率生成的，他们设计概率模型来拟合真实的网络结构（即根据概率模型生成的图与真实图尽可能的相似）。结构图聚类的另一项相关工作是使用非负矩阵分解（NMF）技术。这些算法基于可将邻接矩阵分解为社区隶属度矩阵的线性组合的原理。这些方法都是直接利用原始玩过拓扑结构，忽略了固有的社区结构。</p><p>​        <strong>属性图聚类：</strong>在文献中，已经有多重属性图聚类的方法，其中具有代表性的一种方法是利用一种判别模型，通过选择权重向量将节点属性合并到网络结构模型中。除了构建生成模型之外，其他一些方法还利用NMF技术来组合网络结构和节点属性，最先进的算法之一是SCI，它使用NMF技术将观察到的网络结构和节点属性相结合。然而，SCI直接分解邻接矩阵，而没有专注于分解节点属性矩阵，这忽略了边在形成社区结构中的各种意义，并导致无法充分利用节点属性。</p><p>​        不同于这些结构图聚类和属性图聚类算法，我们开发了一种新颖的社区结构嵌入矩阵来编码固有的社区结构，而不是简答地使用观察到的网络拓扑进行社区检测。此外，我们的工作重点是同时分解社区结构嵌入矩阵和节点嵌入矩阵，以产生更好的性能。</p><p>​        <strong>网络嵌入：</strong>本文的工作涉及网络嵌入，该网络学习用于表示节点的潜在向量。DeepWalk是具有代表性的网络嵌入算法之一，它通过将随机游走生成的节点序列看做是NLP中的句子来获得节点的向量表示。此外，也有人将社区结构结合到节点嵌入中。不同于现有的网络嵌入方法，本文的工作通过固有的社区隶属度对固有的社区结构进行编码，以用于社区检测。</p><h2 id="3-Preliminaries"><a href="#3-Preliminaries" class="headerlink" title="3. Preliminaries"></a>3. Preliminaries</h2><p><strong>问题陈述：</strong></p><p>​        给定无向有权重属性图$G=(V,E,W,T)$，$V=\{v_1,v_2,…,v_n\}$为点集，$E\subseteq V\times V$为边集，$W_{ij}$表示边$(v_i,v_j)$的权重，$T\in \{0,1\}_{n\times s}$是节点的属性矩阵，矩阵第$i$行表示了节点$v_i$的s维二元向量。此外，定义邻接矩阵为$A\in \{0,1\}_{n\times n}$。本文主要讨论无向无权重图，但是本文提出的模型可以拓展到有向有权重图。在本文的无权重图$G$中，$W_{ij}=A_{ij}=\{0,1\}$。</p><p>​        给定一张属性图$G$，其中有$K$个社区，社区发现任务即中找出$K$个节点群$\cal G= \{g_1,…g_\rm K\}$使得：（1）相同节点群内节点连接非常紧密，不同节点群的节点间连接非常稀疏（2）相同节点群内节点具有相同的属性，不同节点群内的节点具有不同的属性。另外，本文中的社区发现问题是允许社区间存在重叠，即$g_i\cap g_j \neq\emptyset$。</p><p><strong>Nonnegative Matrix Factorization（非负矩阵分解）：</strong></p><p>​        给定$n$个节点和$K$个社区，我们定义社区隶属度矩阵$U_{n\times K}$，其中$U_{ij}$表示了第$i$个节点属于第$j$的概率。根据隶属度矩阵计算存在边的数量$UU^T$应该拟合通过邻接矩阵$A$得到的链接数。因此，基于最小化重建成本，可以将社区发现问题表示为(SNMF)：<br>$$<br>\mathop{min}\limits_{U\geq0}||A-UU^T||_F^2\tag{1}<br>$$<br>​        SNMF使用了上述公式（1），这有着一个严重缺陷，它通过分解邻接矩阵$A$只利用了网络的拓扑结构。对于每对相连的节点对$v_i$和$v_j$，无论它们是否属于同一个社区，$A_{ij}=1$。因此，固有的社区截割头不能通过邻接矩阵$A$来表示。为了解决这个缺陷，我们设计了新颖的社区结构嵌入方法。</p><h2 id="4-Community-Structure-Embedding"><a href="#4-Community-Structure-Embedding" class="headerlink" title="4. Community Structure Embedding"></a>4. Community Structure Embedding</h2><p>​        为了更好地描述图中固有的社区结构，我们提出了一种新颖的社区结构嵌入方法，根据节点潜在的社区隶属相似性来量化节点的结构紧密度。具体而言，我们设计了一个评估社区隶属相似度的函数$\cal F$。然后根据相似度指标，我们采用基于负采样的Skip-gram来探索网络结构并描述潜在的社区结构。最后我们获得了对固有社区结构编码的社区结构嵌入矩阵。</p><p><strong>Community Membership Similarity：</strong></p><p>​        我们从一个简洁合理的观察开始，因为节点在社区中紧密相连，所以每个链接的节点都应具有一定的属于同一社区的趋势。定义评估社区隶属相似度的函数${\cal F} (i,j)\in[0,1)$：<br>$$<br>{\cal F}(i,j)=2\sigma(U_{i:}U_{j:}^T)-1=2\times(\frac{1}{1+e^{-U_{i:}U_{j:}^T}}-1)<br>\tag{2}<br>$$<br>​        之所以选择sigmoid函数，是因为对于所有实数输入值，它都有界可微的实函数（real function）。因为${\cal F} (i,j)$只是$\sigma(U_{i:}U_{j:}^T)$的非线性变换，因此我们只讨论$\sigma(U_{i:}U_{j:}^T)$。</p><p><strong>Community Structure Embedding Matrix (M)：</strong></p><p>​        社区结构嵌入的方法主要是：最大化实际相连节点$v_i$和$v_j$的$\sigma(U_{i:}U_{j:}^T)$，同时最小化随机选择的两个节点</p><p>$v_i$和$v_j$的$\sigma(U_{i:}U_{j:}^T)$。在现实世界中，大多数大规模图都是非常稀疏的，随机选择的两个节点相连的概率是非常低的。因此，通过基于负采样的Skip-gram，定义目标函数如下：<br>$$<br>{\cal l}(i,j)=W_{ij}\big(log\sigma(U_{i:}U_{j:}^T)+{k}{\Bbb E}_{j_N\sim P_V}[log\sigma(-U_{i:}U_{j_N:}^T)]\big)<br>\tag{3}<br>$$<br>式中：$k$为负采样的样本数，$log\overset{\text{def}}{=}log_e$，$j_N$是根据经验分布$P_V(i)=\frac{d_i}{D}$，其中$d_i=\sum_jW_{ij}$是节点 $i$ 的度数，$D=\sum_id_i$是图$G$总度数。将上述内容带入公式（3）：<br>$$<br>{\cal l}(i,j)=W_{ij}log\sigma(U_{i:}U_{j:}^T)+{k}\frac{d_id_j}{D}log\sigma(-U_{i:}U_{j_N:}^T)<br>\tag{4}<br>$$<br>接下来对公式（4）求导：<br>$$<br>\frac{\partial{l(i,j)}}{\partial({U_{i:}U_{j:}^T)}}=W_{ij}\sigma(-U_{i:}U_{j:}^T)-{k}\frac{d_id_j}{D}\sigma(U_{i:}U_{j_N:}^T)<br>\tag{5}<br>$$<br>最后，通过将公式（5）=0，可以得到任意节点对的最优社区结构嵌入，并得出：<br>$$<br>U_{i:}U_{j:}^T=log\frac{W_{ij}D}{d_id_j}-logk<br>\tag{6}<br>$$<br>公式（6）可能是负的，如果为负，则设置为0。基于以上分析结果，我们定义一个新的社区结构嵌入矩阵：<br>$$<br>M_{ij}=max\{U_{i:}U_{j:}^T,0\}=max\{log\frac{W_{ij}D}{d_id_j}-logk,0\}<br>\tag{7}<br>$$<br>对于每对不相连的$W_{ij}=0$节点对$v_i$和$v_j$，我们设置相应的$M_{ij}=0$。</p><p>​        社区结构嵌入矩阵可以对潜在的紧密相连的子图进行编码，并探索固有的社区结构。此外，它可以容易地拓展到各种网络（有向无向，有权重无权重），有这广阔的应用场景。</p><p><strong>Example：</strong></p><p>​        举个简单例子，以证明社区结构嵌入矩阵$M$（k=2）在无权重图对固有社区结构编码的优越性能。图1（a）说明了有两个社区的无权重图，由于邻接矩阵$A$对每条边都设置了相同的值1，因此在发现两个社区时，无法确定那条边更重要。而如图1（b）社区结构嵌入矩阵可以为每个社区内的链接设置更高的权重，而为两个社区之间的链接设置更小的权重。特别是，社区结构嵌入矩阵降低了高度数节点间连接的权重，因为它们更可能在划分社区中发挥关键作用。如图1（a），节点$v_1$和节点$v_2$都有着最大的度数，因此删除（b）中边$(v_1,v_2)$，即$M_{v_1v_2}=0$。</p><p><strong>Structure Embedding based Optimization：</strong></p><p>​        不同于基于NMF的研究（如SNMF）直接通过邻接矩阵$A$利用图结构，本文使用社区结构嵌入矩阵来描述固有的社区结构。</p><p>​        不考虑属性时，使用社区结构嵌入矩阵进行社区发现的问题可以表示为：<br>$$<br>\mathop{min}\limits_{U\geq0}{\cal L}(U)=||M-UU^T||_F^2<br>\tag{8}<br>$$</p><h2 id="5-CDE-Model"><a href="#5-CDE-Model" class="headerlink" title="5. CDE Model"></a>5. CDE Model</h2><p>​        在本节中，我们提出CDE模型，来解决使用结构信息和节点属性信息对属性图进行社区发现的问题。</p><p><strong>Community Attributes：</strong></p><p>​        回想一下，在属性图中，社区不仅应具有紧密连接的结构，而且还应具有相同的属性。此外，不同的社区具有不同的属性。因此，我们定义社区属性矩阵$C\in R_{K\times s}$，其中$C_{ir}$表示第$i$个社区对第$r$维节点属性的偏向。</p><p>​        我们将社区隶属度和社区属性的发现公式转化为非负矩阵分解问题，通过对节点属性矩阵进行分解来优化社区隶属度矩阵$U$和社区属性矩阵$C$：<br>$$<br>\mathop{min}\limits_{U\geq0,C\geq0}{\cal L}(C)=||T-UC||_F^2+\alpha\sum_i||C_{:i}||_1^2<br>\tag{9}<br>$$<br>式中：$\alpha$是一个非负参数，来控制矩阵$C$的稀疏性。</p><p>​        因为不同的社区倾向于拥有不同的属性，甚至，某些属性因此会互斥。为了解决这个问题，我们在C的每一列中使用了l1范数稀疏性，这减少了每个社区的不重要节点属性的干扰。</p><p><strong>Unified Objective Function for CDE：</strong></p><p>​        在属性图$G$中，CDE的目标是找到K个社区，并且相同社区内的节点紧密相连且拥有相同的属性。通过将社区结构嵌入的目标函数和节点属性分别合并为公式（8）和公式（9），定义最终的CDE的目标函数如下：<br>$$<br>\mathop{min}\limits_{U\geq0,C\geq0}{\cal L}(U,C)=||T-UC||_F^2+\alpha\sum_i||C_{:i}||_1^2+\beta||M-UU^T||_F^2<br>\tag{10}<br>$$<br>式中：$\beta$是一个正参数，用于平衡节点属性矩阵$T$和社区结构嵌入矩阵$M$。更大的$\beta$会导致更依赖于社区结构嵌入矩阵$M$的分解来确定社区。</p><p><strong>Identify Communities by U：</strong></p><p>​        对于节点$v_i$，定义包含节点$v_i$的社区集合为$\psi(i)\subseteq\{1,…,K\}$。通过对公式（10）的优化后，我们获得了最佳的社区隶属度矩阵$U$。为了识别不重叠的社区，我们找出$v_i$对应的值最大的$U_{i:}$，即$\psi(i)=argmax_{1\leq j\leq K}U_{ij}$。对于重叠的社区发现问题，当$U_{ij}$大于某个阈值时，则认为节点$v_i$属于第$j$个社区，即$\psi(i)={1\leq j\leq K|U_{ij}&gt;\varepsilon}$。本文的实验中，设置阈值$\varepsilon-0.1$。</p><p><strong>Iteratively Updating Rules for CDE：</strong></p><p>​        由于目标函数（10）不是凸函数，我们采用了一个迭代更新规则。在每次迭代中，先固定$C$更新$U$，然后固定$U$更新$C$。</p><ol><li><p>首先固定$C$，更新$U$：<br>$$<br>\mathop{min}\limits_{U\geq0}{\cal L}(U)=\beta||M-UU^T||_F^2+||T-UC||_F^2<br>\tag{11}<br>$$<br>初始化$U$后，可以按下式对$U$进行更新：<br>$$<br>U_{ij}\leftarrow U_{ij}(\frac{(TC^T-UCC^T+2\beta MU)_{ij}}{(2\beta UU^TU)_ij})^{\frac{1}{4}}<br>\tag{12}<br>$$</p></li><li><p>固定$U$，更新$C$：<br>$$<br>\mathop{min}\limits_{C\geq0}{\cal L}(C)=||T-UC||_F^2+\alpha\sum_i||C_{:i}||_1^2<br>\tag{13}<br>$$<br>按下式对$C$进行更新：<br>$$<br>C_{ij}\leftarrow C_{ij}\frac{(U’^TT’)_{ij}}{(U’^TU’C)_{ij}}<br>\tag{15}<br>$$</p></li></ol><p><strong>Proof of Convergence:</strong></p><p>…………………</p><h2 id="6-Experiments"><a href="#6-Experiments" class="headerlink" title="6. Experiments"></a>6. Experiments</h2><p><strong>数据集：</strong></p><p>数据集的详细信息如下图所示：</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/数据集信息.png" alt="数据集信息" style="zoom:50%;"><p><strong>参数敏感性分析：</strong></p><p>​        在Wisconsin数据集上进行参数敏感性实验。CDE模型有着以下参数：</p><p>（1）$\alpha$：负，控制社区属性矩阵$C$的稀疏性</p><p>（2）$\beta$：正，平衡节点属性和社区结构嵌入的作用</p><p>（3）$k$：决定负采样的数量</p><p>​        首先设置$\alpha=\beta=1$，即认为节点属性和社区结构嵌入是同等重要，然后改变从1到100$k$，记录结果：</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/参数敏感性实验1.png" alt="参数敏感性实验1" style="zoom:50%;"><p>可以观察到，$k=22$到$k=29$区间，得分较好。$k=25$时得分最高，AC=0.6645，NMI=0.409。</p><p>​        接下来，设置$k=25$，然后改变$\alpha$和$\beta$，结果如下图所示：</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/参数敏感性实验2.png" alt="参数敏感性实验2" style="zoom:50%;"><p>可以看到，$\alpha=1,\beta=2$时，得分最高，AC=0.7321，NMI=0.4284。</p><p><strong>重叠社区评估：</strong></p><p>评估方法：每个被发现的社区匹配与它最相思的真实社区。给定被发现的社区集合$C$和现实存在的社区集合$C^<em>$，F1-Score和Jaccard的统一描述定义如下：<br>$$<br>\frac{1}{2|C^</em>|}\sum_{C_i^<em>\in C^</em>}\mathop{max}\limits_{C_j\in C}\delta(C_i^<em>,C_j)+\frac{1}{2|C|}\sum_{C_j\in C}\mathop{max}\limits_{C_j^</em>\in C^<em>}\delta(C_i^</em>,C_j)<br>$$<br>当$\delta(C_i^<em>,C_j)$ 定义为 $C_i^</em>$ 和 $C_j$ 的调和平均数（倒数平均数）时，即为F1-Score矩阵；当 $\delta(C_i^<em>,C_j)=\frac{C_i^</em>\cap C_j}{C_i^*\cup C_j}$ 时，即为Jaccard矩阵。两个矩阵都是更高的分数代表了更好的性能。实验结果如下图所示：</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/重叠社区实验.png" alt="重叠社区实验" style="zoom:50%;"><p><strong>无重叠社区评估：</strong></p><p>评估方法：AC和NMI</p><p>实验结果如下图所示：</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/无重叠社区实验.png" alt="无重叠社区实验" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Embedding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph Attention Networks</title>
      <link href="/2020/08/20/graph-attention-networks/"/>
      <url>/2020/08/20/graph-attention-networks/</url>
      
        <content type="html"><![CDATA[<h1 id="Graph-Attention-Networks"><a href="#Graph-Attention-Networks" class="headerlink" title="Graph Attention Networks"></a>Graph Attention Networks</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>​        人类的注意力机制（Attention Mechanism）是从直觉中得到的，它是人类利用有限的注意力资源从大量的信息中快速筛选出高价值信息的手段。</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/人类的注意力机制.png" alt="人类的注意力机制" style="zoom:50%;"><p>​        借鉴人类的注意力机制原理，将其运用到NLP，CV中，都已经取得了非常好的表现。 注意机制的好处之一是，它们允许处理大小可变的输入，着重于决策中输入最相关的部分。 当使用注意力机制来计算单个序列的表示时，通常将其称为自我注意力或内部注意力。 </p><p>注意力机制有趣的属性：</p><p>（1）计算速度快，可以在不同节点上进行并行操作</p><p>（2）通过对邻域节点指定权重，可以泛化应用到任意具有不同度的节点</p><p>（3）是一种inductive的模型，可以泛化到没有参与训练的节点</p><p>​        GAT是为图上的节点分类任务设计，思想很简单，GAT中目标节点的向量表示是受其他节点的影响的，因此通过注意力机制找出对目标节点影响更大的节点，让它们参与到目标节点的嵌入过程中去，使得向量表示更准确。</p><p>​        就好比是给一个人A作评价，然后需要找一些人对A作评价，根据这些人对A的评价，最后给出最终评价。如果随机找人来作评价肯定是不合适的，比较科学合适的方法是，找出A的亲朋好友，让他们来作评价，他们和A的关系更亲密，他们的评价也会更有参考价值，使最终的评价更准确。</p><h2 id="GAT-Architecture"><a href="#GAT-Architecture" class="headerlink" title="GAT Architecture"></a>GAT Architecture</h2><h3 id="Graph-Attention-Layer"><a href="#Graph-Attention-Layer" class="headerlink" title="Graph Attention Layer"></a>Graph Attention Layer</h3><p>​        该层的输入是一组节点的特征，h = {$\vec{h_1},\vec{h_2},…,\vec{h_N}$}，$\vec{h_N}\in R^F$，其中 N 是节点数，F 是节点的特征维数，该层会生成一组新的节点特征作为该层的输出，$h’={}${$\vec{h’_1},\vec{h’_2},…,\vec{h’_N}$}，$\vec{h’_N}\in R^{F’}$。</p><p>​        第一步，通过共享权重矩阵$W\in R^{F’\times F}$对每个节点参数做线性变换，即对节点特征的增维，然后引入注意力机制，$a:R^{F’}\times R^{F’}\to R$，计算<strong>初步注意力系数</strong>：<br>$$<br>e_{ij}=a(W\vec H_i,W\vec H_j)<br>\tag{1}<br>$$<br>$(,)$表示将两个向量进行拼接，$a$ 表示将拼接后的向量映射为一个实数。注意力系数表示了节点 $j$ 对节点 $i$ 的重要程度。得到初步注意力系数后，用Softmax进行归一化：<br>$$<br>\alpha_{ij} = softmax_j(e_{ij})=\frac{exp(e_{ij})}{\sum_{k\in N_i}exp(e_{ik})}<br>\tag{2}<br>$$<br>式中：$N_i$表示节点 $i$ 的邻域节点。</p><p>​        在本文的实验中，注意力机制$a$是由权重向量 $\vec a\in R^{2F’}$参数化单层前馈神经网络，并使用激活函数LeakyReLU（负输入斜率$\alpha=0.2$），完全展开后，<strong>最终注意力系数</strong>为：<br>$$<br>\alpha_{ij}=\frac{exp(LeakyReLU(\vec a^T[W\vec h_i||W\vec h_j]))}{\sum_{k\in N_i}exp(LeakyReLU(\vec a^T[W\vec h_i||W\vec h_k]))}<br>\tag{3}<br>$$<br>其中，$\cdot^T$表示转置，||表示向量连接，过程如下图所示：</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/注意力系数.png" alt="注意力系数" style="zoom:40%;"><p>​        获得归一化的注意力系数后，把邻域节点的特征向量进行加权求和，最后将结果做一次非线性变换，以此作为每个节点最终的特征输出向量：<br>$$<br>\vec {h’_i}=\sigma (\sum_{j\in N_i}\alpha_{ij}W\vec h_j)<br>\tag{4}<br>$$</p><h3 id="Multi-Head-Attention"><a href="#Multi-Head-Attention" class="headerlink" title="Multi-Head Attention"></a>Multi-Head Attention</h3><p>​        为了稳定自我注意力的学习过程，引入多头注意力机制。</p><h4 id="Concat："><a href="#Concat：" class="headerlink" title="Concat："></a>Concat：</h4><p>​        由K个独立的注意力机制执行等式4的转换，然后将它们的特征连接起来，从而得到以下输出特征表示：<br>$$<br>\vec{h’_i}=||_{k=1}^K(\sigma(\sum_{j\in N_i}\alpha_{ij}^kW^k\vec h_j))<br>\tag{5}<br>$$<br>​        其中，||为向量拼接操作，$\alpha_{ij}^k$是第$K$个注意力机制计算出的归一化注意力系数，$W^k$是相应的输入线性变化的权重矩阵。注意，在此设定下，最终返回的输出$h’$的维数为$KF’$。可以理解为多个卷积核的操作，每个注意力机制处理一部分的特征，最后将结果做一个拼接。</p><h4 id="Average："><a href="#Average：" class="headerlink" title="Average："></a>Average：</h4><p>​        如果我们在网络的最终层上进行多头关注，则向量拼接是没有意义的，因此采用求平均，最后做非线性变化：<br>$$<br>\vec {h’_i}=\sigma(\frac{1}{K}\sum_{k=1}^K\sum_{j\in N_i}\alpha_{ij}^kW^k\vec h_j)<br>\tag{6}<br>$$<br>下图说明了多头注意力机制的聚合过程：</p><img src="https://dede-photo.oss-cn-beijing.aliyuncs.com/img/多头注意力机制.png" alt="多头注意力机制" style="zoom:40%;">]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Embedding </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
